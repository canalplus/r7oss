/************************************************************************
Copyright (C) 2011 STMicroelectronics. All Rights Reserved.

This file is part of the stm_fe Library.

stm_fe is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License version 2 as published by the
Free Software Foundation.

stm_fe is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along
with stm_fe; see the file COPYING.  If not, write to the Free Software
Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.

The stm_fe Library may alternatively be licensed under a proprietary
license from ST.

Source file name : stv0367qam_drv.c
Author :           LLA

367 lla drv file

Date        Modification                                    Name
----        ------------                                    --------
01-Aug-11   Created
04-Jul-12   Updated to v1.9
************************************************************************/

/* includes ---------------------------------------------------------------- */

/*	generic includes	*/
#ifndef ST_OSLINUX
/*	#include <stdio.h>
	#include <stdlib.h>
	#include <string.h>
	#include <math.h>	 */
#endif
#include <linux/kernel.h>
#include <linux/list.h>
#include <linux/platform_device.h>
#include <linux/stm/plat_dev.h>
#include <linux/stm/demod.h>
#include <linux/stm/lnb.h>
#include <linux/stm/diseqc.h>

#include <stm_registry.h>
#include <stm_fe.h>
#include <stfe_utilities.h>
#include <stm_fe_os.h>
#include <i2c_wrapper.h>
#include <stm_fe_demod.h>
/* #include <stm_fe_diseqc.h>
#include <fesat_commlla_str.h> */
#include "stv0367qam_init.h"
#include "stv0367qam_drv.h"
#include "stv0367qam_util.h"
#include <fe_tc_tuner.h>
#include <gen_macros.h>
/* common includes */

#if defined(HOST_PC) && !defined(NO_GUI)
#include <Appl.h>
#include <UserPar.h>
#include <Pnl_report.h>
#include <367qam_Report_Msg.h>
#define REPORTMSG(a, b, c) Report367qam(a, b, c);
#define DBG_SEARCHALGO
	/*#define DBG_SCANPROFILE */
#else
#define REPORTMSG(a, b, c)
#endif

/* Current LLA revision	*/
static const ST_Revision_t Revision367qam = "STV0367QAM - LLA_REL_2.0";

/* RF Level Lookup Table, depends on the board and tuner. */
#define RF_LOOKUP_TABLE_SIZE  31
#define RF_LOOKUP_TABLE2_SIZE 16
#define RF_LOOKUP_Tda18212_TABLE1_SIZE 21
#define RF_LOOKUP_Tda18212_TABLE2_SIZE 16

/* RF Level(for RF AGC->AGC1) Lookup Table, depends on the board and tuner.*/
S32 FE_367qam_RF_LookUp1[RF_LOOKUP_TABLE_SIZE][RF_LOOKUP_TABLE_SIZE] = {
/*AGC1*/ {48, 50, 51, 53, 54, 56, 57, 58, 60, 61, 62, 63, 64, 65, 66,
	  67, 68, 69,
	  70, 71, 72, 73, 74, 75, 76, 77, 78, 80, 83, 85, 88},
/*RF(dbm)*/ {22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36,
	     37, 38, 39,
	     41, 42, 43, 44, 46, 47, 49, 50, 52, 53, 54, 55, 56}
};

/* RF Level(for IF AGC->AGC2) Lookup Table, depends on the board and tuner.*/
S32 FE_367qam_RF_LookUp2[RF_LOOKUP_TABLE2_SIZE][RF_LOOKUP_TABLE2_SIZE] = {
/*AGC2*/ {28, 29, 31, 32, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44,
	  45},
/*RF(dbm)*/ {57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71,
	     72}
};

/* RF Level(for RF AGC->AGC1) Lookup Table, depends on the board and tuner.*/
S32 FE_367qam_Tda18212_RF_LookUp1[RF_LOOKUP_Tda18212_TABLE1_SIZE]
	[RF_LOOKUP_Tda18212_TABLE1_SIZE] = {
/*RfAGC*/ {19, 21, 23, 25, 26, 27, 29, 30, 32, 33, 35, 37, 39, 47,
	   50, 53, 56, 59, 61, 64, 65},
/*RF(dbm)*/ {22, 24, 30, 35, 39, 40, 42, 44, 48, 49, 50, 51, 53,
	     54, 56, 58, 60, 62, 64, 66, 68}
};

/* RF Level(for IF AGC->AGC2) Lookup Table, depends on the board and tuner.*/
S32 FE_367qam_Tda18212_RF_LookUp2[RF_LOOKUP_Tda18212_TABLE2_SIZE]
	[RF_LOOKUP_Tda18212_TABLE2_SIZE] = {
/*IFAGC2*/ {17, 19, 20, 21, 22, 24, 26, 28, 30, 32, 34, 36, 38, 40, 42,
	    44},
/*RF(dbm)*/ {69, 70, 71, 72, 73, 74, 75, 77, 79, 80, 81, 83, 85, 86, 87,
	     89}
};

static S32 AllPass[1000][4] =	/*  c[1], c[2], c[3], c[4] */
{
	{0x3C9DE9, 0x3A1EF6, 0x38E6C9, 0x36DA5C},
	{0x3C9CC6, 0x3A1D86, 0x38E5B2, 0x36D9C7},
	{0x3C9917, 0x3A17B3, 0x38DF58, 0x36D275},
	{0x3C94C7, 0x3A10CD, 0x38D7B9, 0x36C989},
	{0x3C919F, 0x3A0BE5, 0x38D27C, 0x36C3A9},
	{0x3C8CB1, 0x3A03F2, 0x38C99E, 0x36B926},
	{0x3C8746, 0x39FB28, 0x38BFBE, 0x36AD5D},
	{0x3C80F6, 0x39F0D6, 0x38B40D, 0x369F41},
	{0x3C7A44, 0x39E5DF, 0x38A796, 0x36902C},
	{0x3C72AE, 0x39D95F, 0x38994D, 0x367EC5},
	{0x3C6AA1, 0x39CC17, 0x388A16, 0x366C32},
	{0x3C618D, 0x39BD0D, 0x3878C9, 0x3656F9},
	{0x3C579B, 0x39AC86, 0x3865B6, 0x363F7A},
	{0x3C4DB3, 0x399C17, 0x3852C6, 0x362833},
	{0x3C3F9E, 0x39847E, 0x383748, 0x3605FF},
	{0x3C3671, 0x397555, 0x3825E5, 0x35F0BA},
	{0x3C2D6B, 0x396675, 0x3814DD, 0x35DBEF},
	{0x3C27D0, 0x395D76, 0x380ADD, 0x35D021},
	{0x3C1DAD, 0x394CBA, 0x37F7AE, 0x35B8A9},
	{0x3C162D, 0x394075, 0x37E9C0, 0x35A7D1},
	{0x3C0EAE, 0x39343F, 0x37DBF2, 0x359733},
	{0x3BF7C3, 0x390DA7, 0x37AEBC, 0x355E99},
	{0x3BF085, 0x3901E0, 0x37A174, 0x354EA5},
	{0x3BE6C1, 0x38F1D2, 0x378F1D, 0x35384D},
	{0x3BE087, 0x38E7D8, 0x37840B, 0x352B3E},
	{0x3BD58B, 0x38D5B6, 0x376F3E, 0x3511C6},
	{0x3BC9D9, 0x38C267, 0x375915, 0x34F6A0},
	{0x3BB38E, 0x389D01, 0x372D6E, 0x34C02D},
	{0x3BAFC7, 0x38973F, 0x372768, 0x34B992},
	{0x3BA6AB, 0x388865, 0x371698, 0x34A545},
	{0x3B9CC0, 0x38782D, 0x37042B, 0x348EF0},
	{0x3B9775, 0x386FDA, 0x36FB20, 0x348488},
	{0x3B910E, 0x3865A4, 0x36EFDA, 0x34774B},
	{0x3B761E, 0x38387C, 0x36BB2A, 0x343591},
	{0x3B6EBE, 0x382CA7, 0x36ADFF, 0x3425F9},
	{0x3B673C, 0x38209C, 0x36A099, 0x34161B},
	{0x3B5F02, 0x38135B, 0x3691C6, 0x34046F},
	{0x3B562E, 0x380514, 0x3681C0, 0x33F142},
	{0x3B4CE0, 0x37F604, 0x3670D0, 0x33DCF1},
	{0x3B3732, 0x37D1F4, 0x36470E, 0x33A940},
	{0x3B2C88, 0x37C09E, 0x363378, 0x3391A2},
	{0x3B274B, 0x37B87E, 0x362AC6, 0x3387CB},
	{0x3B1B42, 0x37A4D9, 0x36147A, 0x336CC5},
	{0x3B1541, 0x379B73, 0x360A4D, 0x336115},
	{0x3B0E91, 0x3790E4, 0x35FEC3, 0x3353AE},
	{0x3B078A, 0x3785C7, 0x35F295, 0x33457D},
	{0x3AEC34, 0x375850, 0x35BDEB, 0x33043B},
	{0x3AE3CD, 0x374AE6, 0x35AF0E, 0x32F2AE},
	{0x3ADAFF, 0x373CD1, 0x359F6A, 0x32E02C},
	{0x3AD18C, 0x372DA9, 0x358E86, 0x32CC18},
	{0x3ACE9D, 0x372982, 0x358A99, 0x32C85D},
	{0x3AC45A, 0x371901, 0x357825, 0x32B259},
	{0x3AAAF1, 0x36EEF7, 0x3547B2, 0x327699},
	{0x3A9F5B, 0x36DC44, 0x3532B5, 0x325D72},
	{0x3A9A90, 0x36D504, 0x352B2D, 0x325538},
	{0x3A9549, 0x36CCF7, 0x3522B6, 0x324BD3},
	{0x3A8F57, 0x36C3C9, 0x3518EC, 0x3240C5},
	{0x3A821D, 0x36AE60, 0x3500CF, 0x3223BF},
	{0x3A6BF0, 0x3689F0, 0x34D718, 0x31F0A5},
	{0x3A64B8, 0x367EAB, 0x34CAE6, 0x31E29F},
	{0x3A553D, 0x366587, 0x34AE7A, 0x31C042},
	{0x3A4D22, 0x3658CA, 0x34A096, 0x31B022},
	{0x3A4D02, 0x365972, 0x34A262, 0x31B3AF},
	{0x3A43D2, 0x364AE9, 0x349268, 0x31A0F5},
	{0x3A2986, 0x361FB5, 0x3460EF, 0x31644F},
	{0x3A1FEB, 0x361083, 0x34503A, 0x3150B8},
	{0x3A1579, 0x35FFE9, 0x343DE4, 0x313B19},
	{0x3A0A88, 0x35EE80, 0x342A9F, 0x312454},
	{0x3A0810, 0x35EB45, 0x3427EA, 0x312248},
	{0x39FC46, 0x35D877, 0x34130C, 0x31098A},
	{0x39F945, 0x35D45B, 0x340F54, 0x31063E},
	{0x39D9CA, 0x35A0B1, 0x33D432, 0x30BDBF},
	{0x39D5D5, 0x359B03, 0x33CEAA, 0x30B834},
	{0x39C819, 0x358508, 0x33B62B, 0x309B02},
	{0x39C332, 0x357DC9, 0x33AED4, 0x30933A},
	{0x39BE2C, 0x35765A, 0x33A748, 0x308B33},
	{0x39B8CC, 0x356E56, 0x339F0F, 0x308257},
	{0x399EF1, 0x35443A, 0x336F39, 0x30481E},
	{0x398E6C, 0x3529B2, 0x335186, 0x30248A},
	{0x3987AB, 0x351F6B, 0x3346B7, 0x30187D},
	{0x3980A2, 0x3514B1, 0x333B65, 0x300BD1},
	{0x397932, 0x35094C, 0x332F50, 0x2FFE34},
	{0x397166, 0x34FD51, 0x33228E, 0x2FEFC4},
	{0x39537D, 0x34CCA9, 0x32EB50, 0x2FAC89},
	{0x394AA8, 0x34BEFE, 0x32DCA2, 0x2F9BBC},
	{0x394C91, 0x34C327, 0x32E29A, 0x2FA498},
	{0x39430F, 0x34B461, 0x32D2A8, 0x2F923E},
	{0x393930, 0x34A507, 0x32C20F, 0x2F7F1A},
	{0x392F09, 0x349539, 0x32B0F3, 0x2F6B57},
	{0x3918BF, 0x347158, 0x3288A6, 0x2F3AD0},
	{0x390D3B, 0x345F50, 0x3274FF, 0x2F23EE},
	{0x3901DF, 0x344D8E, 0x3261AF, 0x2F0D7C},
	{0x3901C3, 0x344E65, 0x3263D8, 0x2F11A6},
	{0x38F57B, 0x343B24, 0x324ED2, 0x2EF91B},
	{0x38E8A7, 0x342700, 0x3238CB, 0x2EDF55},
	{0x38E7D3, 0x3426AB, 0x32399E, 0x2EE1DC},
	{0x38CDA0, 0x33FC82, 0x320A3C, 0x2EA8C0},
	{0x38BF61, 0x33E615, 0x31F1A0, 0x2E8BD7},
	{0x38BD95, 0x33E42D, 0x31F0A7, 0x2E8C29},
	{0x38AEAA, 0x33CCAD, 0x31D6D6, 0x2E6DCB},
	{0x38AC3B, 0x33C9BB, 0x31D4AF, 0x2E6CAC},
	{0x389C58, 0x33B0AA, 0x31B917, 0x2E4C22},
	{0x388C05, 0x3396E8, 0x319CBC, 0x2E2AAF},
	{0x387B20, 0x337C3C, 0x317F59, 0x2E07FC},
	{0x38777D, 0x337758, 0x317AFC, 0x2E0429},
	{0x3873A0, 0x337216, 0x317636, 0x2DFFD8},
	{0x38617C, 0x33556C, 0x315695, 0x2DDA6D},
	{0x385CCB, 0x334ED2, 0x315047, 0x2DD43C},
	{0x384A06, 0x33312A, 0x312F8F, 0x2DAD86},
	{0x38364F, 0x3311FE, 0x310D22, 0x2D84BC},
	{0x3830CD, 0x330A16, 0x31055D, 0x2D7CC6},
	{0x382B18, 0x3301DE, 0x30FD3E, 0x2D7462},
	{0x3824F4, 0x32F8F1, 0x30F452, 0x2D6B04},
	{0x381E97, 0x32EFA9, 0x30EB00, 0x2D6129},
	{0x37F986, 0x32B442, 0x30A867, 0x2D10F2},
	{0x37F25D, 0x32A9B5, 0x309DAA, 0x2D0561},
	{0x37EAE8, 0x329EAF, 0x309263, 0x2CF92A},
	{0x37E32A, 0x329333, 0x308699, 0x2CEC55},
	{0x37DB1A, 0x328733, 0x307A3A, 0x2CDEC9},
	{0x37D2B9, 0x327AB3, 0x306D4B, 0x2CD090},
	{0x37CA19, 0x326DD0, 0x305FEE, 0x2CC1D4},
	{0x37B0D4, 0x3245DB, 0x3033BC, 0x2C8D50},
	{0x37A765, 0x3237AE, 0x3024F0, 0x2C7CD8},
	{0x379D94, 0x3228E5, 0x301574, 0x2C6B8C},
	{0x379398, 0x3219D8, 0x3005AD, 0x2C59E7},
	{0x379A1E, 0x32259F, 0x30146E, 0x2C6DA3},
	{0x378F8C, 0x3215A2, 0x300398, 0x2C5AB6},
	{0x37736E, 0x31E933, 0x2FD273, 0x2C2045},
	{0x376809, 0x31D7EB, 0x2FC030, 0x2C0BA3},
	{0x375C51, 0x31C621, 0x2FAD5D, 0x2BF654},
	{0x375027, 0x31B3A0, 0x2F99BC, 0x2BE00C},
	{0x3755A9, 0x31BDBF, 0x2FA69B, 0x2BF17B},
	{0x374903, 0x31AA7B, 0x2F9221, 0x2BDA2D},
	{0x3729D1, 0x317940, 0x2F5BB7, 0x2B997A},
	{0x371C51, 0x3164AA, 0x2F45CC, 0x2B8078},
	{0x3720F7, 0x316D63, 0x2F5112, 0x2B8FF1},
	{0x3712DF, 0x3157DB, 0x2F3A19, 0x2B75A9},
	{0x370464, 0x3141B8, 0x2F2275, 0x2B5A94},
	{0x37088D, 0x3149A9, 0x2F2CDA, 0x2B68FE},
	{0x36E647, 0x3113A7, 0x2EF135, 0x2B2215},
	{0x36D6AA, 0x30FBC1, 0x2ED7A4, 0x2B04B9},
	{0x36DA26, 0x31029B, 0x2EE0CC, 0x2B119E},
	{0x36C9EC, 0x30E9BE, 0x2EC628, 0x2AF2F7},
	{0x36CD21, 0x30F028, 0x2ECED5, 0x2AFF48},
	{0x36BC3B, 0x30D63E, 0x2EB306, 0x2ADF3B},
	{0x36BF1A, 0x30DC1F, 0x2EBB19, 0x2AEAD4},
	{0x369933, 0x30A082, 0x2E7957, 0x2A9CB0},
	{0x369B9C, 0x30A5A4, 0x2E8093, 0x2AA741},
	{0x368939, 0x30896B, 0x2E623E, 0x2A8436},
	{0x368B51, 0x308E0F, 0x2E68EE, 0x2A8E22},
	{0x36783D, 0x3070C1, 0x2E4968, 0x2A69A9},
	{0x3679F5, 0x3074CC, 0x2E4F6D, 0x2A72C6},
	{0x3650C8, 0x30342D, 0x2E083F, 0x2A1E43},
	{0x365201, 0x30376C, 0x2E0D5E, 0x2A2647},
	{0x363D56, 0x3017AE, 0x2DEB34, 0x29FEB5},
	{0x363E27, 0x301A49, 0x2DEF9C, 0x2A05DB},
	{0x3628CE, 0x2FF980, 0x2DCC50, 0x29DCF3},
	{0x362945, 0x2FFB8E, 0x2DD01C, 0x29E360},
	{0x361321, 0x2FD98A, 0x2DAB78, 0x29B8DE},
	{0x361327, 0x2FDAE5, 0x2DAE7C, 0x29BE5A},
	{0x35FC48, 0x2FB7C4, 0x2D88A3, 0x29926F},
	{0x35FC03, 0x2FB8AB, 0x2D8B29, 0x299755},
	{0x35E45A, 0x2F9455, 0x2D6401, 0x2969DE},
	{0x35E39E, 0x2F9480, 0x2D65B5, 0x296DC7},
	{0x35CB20, 0x2F6EE3, 0x2D3D2C, 0x293EB1},
	{0x35CA00, 0x2F6E71, 0x2D3E32, 0x2941CA},
	{0x35B0BE, 0x2F47AC, 0x2D146C, 0x291142},
	{0x35AF29, 0x2F4684, 0x2D14A9, 0x29136B},
	{0x35AD6F, 0x2F4521, 0x2D14A6, 0x291549},
	{0x35AB8E, 0x2F4382, 0x2D1461, 0x2916D8},
	{0x3590E3, 0x2F1A93, 0x2CE840, 0x28E386},
	{0x3575AA, 0x2EF0D3, 0x2CBB45, 0x28AF3C},
	{0x35730A, 0x2EEE0B, 0x2CB9B8, 0x28AF44},
	{0x357045, 0x2EEB08, 0x2CB7EB, 0x28AEFE},
	{0x356D50, 0x2EE7BB, 0x2CB5CE, 0x28AE5A},
	{0x355099, 0x2EBBB6, 0x2C865F, 0x28772D},
	{0x354D31, 0x2EB7B6, 0x2C837D, 0x28759F},
	{0x352F93, 0x2E8A58, 0x2C52A1, 0x283CCE},
	{0x352BAC, 0x2E8595, 0x2C4EE9, 0x283A40},
	{0x35279C, 0x2E8092, 0x2C4AEB, 0x283760},
	{0x352360, 0x2E7B4C, 0x2C46A5, 0x28342B},
	{0x351F1E, 0x2E75FC, 0x2C4254, 0x2830EB},
	{0x34FF6F, 0x2E457C, 0x2C0E19, 0x27F424},
	{0x34FA88, 0x2E3F2E, 0x2C08B3, 0x27EF99},
	{0x34F573, 0x2E389A, 0x2C0300, 0x27EAB5},
	{0x34D49C, 0x2E0665, 0x2BCCFA, 0x27ABE0},
	{0x34CF02, 0x2DFF04, 0x2BC669, 0x27A5F4},
	{0x34C93A, 0x2DF75D, 0x2BBF8C, 0x279FAE},
	{0x34C340, 0x2DEF6B, 0x2BB85D, 0x279909},
	{0x34A0AF, 0x2DBAA3, 0x2B7F9E, 0x27570E},
	{0x349A29, 0x2DB1D9, 0x2B7785, 0x274F53},
	{0x349376, 0x2DA8CD, 0x2B6F26, 0x274747},
	{0x348C93, 0x2D9F76, 0x2B6675, 0x273ED9},
	{0x34857E, 0x2D95D4, 0x2B5D73, 0x27360E},
	{0x347E39, 0x2D8BE7, 0x2B541F, 0x272CE1},
	{0x3476BD, 0x2D81A7, 0x2B4A72, 0x27234C},
	{0x345140, 0x2D4888, 0x2B0D1B, 0x26DBFE},
	{0x344933, 0x2D3D6E, 0x2B0284, 0x26D158},
	{0x3440F2, 0x2D3204, 0x2AF798, 0x26C64C},
	{0x34387C, 0x2D264B, 0x2AEC56, 0x26BADB},
	{0x342FCF, 0x2D1A3D, 0x2AE0B7, 0x26AEFE},
	{0x3426EF, 0x2D0DE2, 0x2AD4C8, 0x26A2C2},
	{0x341DD6, 0x2D0132, 0x2AC87C, 0x26961A},
	{0x341490, 0x2CF43E, 0x2ABBE7, 0x26891D},
	{0x340B09, 0x2CE6E7, 0x2AAEE7, 0x267BA1},
	{0x340150, 0x2CD945, 0x2AA197, 0x266DCA},
	{0x33F766, 0x2CCB58, 0x2A93F8, 0x265F95},
	{0x33ED3E, 0x2CBD10, 0x2A85F7, 0x2650ED},
	{0x33C28D, 0x2C7C4A, 0x2A4099, 0x260063},
	{0x33B7C1, 0x2C6D0E, 0x2A3196, 0x25F092},
	{0x33CD80, 0x2C904A, 0x2A59E3, 0x26228D},
	{0x33C264, 0x2C8093, 0x2A4A58, 0x261218},
	{0x33B71D, 0x2C709A, 0x2A3A89, 0x260155},
	{0x33AB9E, 0x2C604F, 0x2A2A62, 0x25F02C},
	{0x337E4B, 0x2C1BB1, 0x29E100, 0x259B06},
	{0x33721E, 0x2C0A67, 0x29CFCF, 0x2588AB},
	{0x3387B3, 0x2C2D4B, 0x29F7A7, 0x25BA0A},
	{0x337B40, 0x2C1B95, 0x29E5FD, 0x25A71F},
	{0x336E90, 0x2C0984, 0x29D3F4, 0x2593C5},
	{0x3361A4, 0x2BF719, 0x29C18D, 0x257FFE},
	{0x335476, 0x2BE44D, 0x29AEBE, 0x256BBF},
	{0x33470C, 0x2BD129, 0x299B91, 0x255714},
	{0x333961, 0x2BBDA4, 0x298800, 0x2541F4},
	{0x332B75, 0x2BA9C0, 0x297409, 0x252C5E},
	{0x331D4A, 0x2B9580, 0x295FB3, 0x25165B},
	{0x330EDB, 0x2B80DA, 0x294AF1, 0x24FFDC},
	{0x33002E, 0x2B6BDC, 0x2935D4, 0x24E8F3},
	{0x32F139, 0x2B5674, 0x292046, 0x24D188},
	{0x32E206, 0x2B40B1, 0x290A5B, 0x24B9B4},
	{0x32D28D, 0x2B2A88, 0x28F404, 0x24A164},
	{0x32E7E1, 0x2B4CD4, 0x291B0B, 0x24D1A8},
	{0x32D81F, 0x2B363A, 0x290439, 0x24B8C3},
	{0x32C816, 0x2B1F39, 0x28ECFB, 0x249F64},
	{0x32B7C8, 0x2B07D5, 0x28D557, 0x24858F},
	{0x32A733, 0x2AF009, 0x28BD46, 0x246B3E},
	{0x329659, 0x2AD7D9, 0x28A4CF, 0x245078},
	{0x328534, 0x2ABF3E, 0x288BE7, 0x243532},
	{0x329A69, 0x2AE144, 0x28B28D, 0x2464F5},
	{0x3288F9, 0x2AC835, 0x289929, 0x24491A},
	{0x32773C, 0x2AAEB8, 0x287F51, 0x242CBA},
	{0x32653A, 0x2A94D7, 0x286514, 0x240FE9},
	{0x3252E9, 0x2A7A85, 0x284A61, 0x23F292},
	{0x324050, 0x2A5FCD, 0x282F46, 0x23D4C5},
	{0x322D6B, 0x2A44A9, 0x2813BD, 0x23B67D},
	{0x32427F, 0x2A665E, 0x2839F3, 0x23E5A4},
	{0x322F78, 0x2A4B06, 0x281E2E, 0x23C712},
	{0x321BBD, 0x2A2EA5, 0x280155, 0x23A741},
	{0x3207E9, 0x2A1225, 0x27E461, 0x238756},
	{0x31F3FB, 0x29F585, 0x27C74F, 0x23674D},
	{0x3208C1, 0x2A16B2, 0x27ECE3, 0x2395AC},
	{0x31F449, 0x29F942, 0x27CEF3, 0x23749B},
	{0x31DF7E, 0x29DB5D, 0x27B08B, 0x235305},
	{0x31CA61, 0x29BD04, 0x2791AE, 0x2330EB},
	{0x31B4F8, 0x299E42, 0x277267, 0x230E5E},
	{0x31C9DA, 0x29BF85, 0x279800, 0x233CB2},
	{0x31B414, 0x29A038, 0x277823, 0x231971},
	{0x319DF9, 0x298073, 0x2757CE, 0x22F5AA},
	{0x31B2D3, 0x29A1A6, 0x277D53, 0x2323E9},
	{0x3170C9, 0x293F8F, 0x2715CB, 0x22ACA0},
	{0x318591, 0x296093, 0x273B0B, 0x22DA79},
	{0x316E71, 0x293F5B, 0x271939, 0x22B500},
	{0x3156FA, 0x291DAA, 0x26F6EF, 0x228F04},
	{0x316BB9, 0x293E9B, 0x271C16, 0x22BCC1},
	{0x3153E0, 0x291C59, 0x26F92F, 0x22960A},
	{0x313BAF, 0x28F99E, 0x26D5D1, 0x226ED0},
	{0x312329, 0x28D66F, 0x26B202, 0x22471D},
	{0x3137D3, 0x28F72F, 0x26D6E7, 0x22747E},
	{0x311EEA, 0x28D36E, 0x26B27B, 0x224C11},
	{0x3105A5, 0x28AF2E, 0x268D93, 0x22231D},
	{0x311A44, 0x28CFD5, 0x26B257, 0x225055},
	{0x310099, 0x28AB01, 0x268CD0, 0x2226A5},
	{0x30E692, 0x2885AF, 0x2666CF, 0x21FC70},
	{0x30CC2E, 0x285FE0, 0x264054, 0x21D1B7},
	{0x30E0B7, 0x288052, 0x2664CE, 0x21FE88},
	{0x30C5EB, 0x2859EB, 0x263DB1, 0x21D312},
	{0x30DA72, 0x287A5C, 0x26622E, 0x21FFEE},
	{0x30BF3D, 0x28535A, 0x263A6E, 0x21D3B7},
	{0x30A3A8, 0x282BD9, 0x261233, 0x21A6FC},
	{0x3087B1, 0x2803D5, 0x25E97A, 0x2179BB},
	{0x309C20, 0x28240C, 0x260DA5, 0x21A624},
	{0x307FBF, 0x27FB6D, 0x25E449, 0x217824},
	{0x30942A, 0x281BA0, 0x260871, 0x21A491},
	{0x30775B, 0x27F261, 0x25DE6D, 0x2175CB},
	{0x305A27, 0x27C89F, 0x25B3EC, 0x214681},
	{0x303C8F, 0x279E58, 0x2588ED, 0x2116B2},
	{0x3050E2, 0x27BE4E, 0x25ACBC, 0x2142A2},
	{0x3032DA, 0x279366, 0x258115, 0x21120F},
	{0x304728, 0x27B353, 0x25A4DE, 0x213DFB},
	{0x3028AE, 0x2787C8, 0x25788C, 0x210CA1},
	{0x3009CB, 0x275BB4, 0x254BBA, 0x20DAC2},
	{0x301E0A, 0x277B7E, 0x256F51, 0x21066B},
	{0x2FFEB4, 0x274EC5, 0x2541D3, 0x20D3C3},
	{0x2FDEF2, 0x272181, 0x2513D4, 0x20A095},
	{0x2FF321, 0x274124, 0x253734, 0x20CBF2},
	{0x2FD2E9, 0x271338, 0x250886, 0x2097FA},
	{0x2FE712, 0x2732D1, 0x252BDE, 0x20C351},
	{0x2FC664, 0x27043E, 0x24FC84, 0x208E92},
	{0x2FA548, 0x26D51F, 0x24CCA8, 0x20594D},
	{0x2FB961, 0x26F491, 0x24EFC8, 0x208457},
	{0x2F97CB, 0x26C4C5, 0x24BF3B, 0x204E47},
	{0x2FABDF, 0x26E42C, 0x24E24F, 0x207946},
	{0x2F89CC, 0x26B3B0, 0x24B10D, 0x204264},
	{0x2F6747, 0x2682A5, 0x247F48, 0x200AFE},
	{0x2F7B48, 0x26A1E1, 0x24A21E, 0x2035A6},
	{0x2F5849, 0x26702B, 0x246FAC, 0x1FFD7A},
	{0x2F6C45, 0x268F5B, 0x249276, 0x202816},
	{0x2F48C4, 0x265CF0, 0x245F4B, 0x1FEF16},
	{0x2F5CB9, 0x267C14, 0x248206, 0x2019A3},
	{0x2F38B6, 0x2648F4, 0x244E22, 0x1FDFCE},
	{0x2F1488, 0x2615AF, 0x241A2E, 0x1FA5FB},
	{0x2F2823, 0x26343C, 0x243C3A, 0x1FCFAE},
	{0x2F0327, 0x25FFD6, 0x24071F, 0x1F948B},
	{0x2F1703, 0x261EBD, 0x242987, 0x1FBEA6},
	{0x2EF181, 0x25E99D, 0x23F3AF, 0x1F82AD},
	{0x2ECB8A, 0x25B3F0, 0x23BD5E, 0x1F463F},
	{0x2EDF53, 0x25D2A7, 0x23DF7F, 0x1F6FF5},
	{0x2EB8D0, 0x259C3B, 0x23A86E, 0x1F32AE},
	{0x2ECC91, 0x25BAE1, 0x23CA7A, 0x1F5C4C},
	{0x2EA5D3, 0x25842A, 0x239322, 0x1F1EB7},
	{0x2EB941, 0x25A256, 0x23B4AD, 0x1F47C0},
	{0x2E91AC, 0x256A75, 0x237C28, 0x1F08D6},
	{0x2EA55E, 0x2588FB, 0x239E0D, 0x1F3244},
	{0x2E7D3C, 0x25505D, 0x2364CC, 0x1EF287},
	{0x2E90E7, 0x256ED4, 0x23869E, 0x1F1BDF},
	{0x2E6838, 0x253577, 0x234CA0, 0x1EDB4E},
	{0x2E7BDA, 0x2553DA, 0x236E59, 0x1F0486},
	{0x2E529C, 0x2519BF, 0x23339F, 0x1EC324},
	{0x2E6637, 0x253812, 0x235543, 0x1EEC43},
	{0x2E3C66, 0x24FD32, 0x2319C7, 0x1EAA07},
	{0x2E4FF7, 0x251B72, 0x233B52, 0x1ED306},
	{0x2E2597, 0x24DFD3, 0x22FF1C, 0x1E8FFC},
	{0x2E3921, 0x24FE01, 0x232090, 0x1EB8DE},
	{0x2E0E2A, 0x24C199, 0x22E395, 0x1E74F9},
	{0x2DE2AE, 0x248498, 0x22A61D, 0x1E30A5},
	{0x2DF621, 0x24A28B, 0x22C73A, 0x1E5907},
	{0x2E0998, 0x24C091, 0x22E878, 0x1E81A4},
	{0x2DDD77, 0x2482A1, 0x22AA00, 0x1E3C1B},
	{0x2DF0E7, 0x24A094, 0x22CB27, 0x1E6499},
	{0x2DC429, 0x2461D7, 0x228BE8, 0x1E1E35},
	{0x2D96E2, 0x24227D, 0x224C2C, 0x1DD764},
	{0x2DAA39, 0x244030, 0x226CF4, 0x1DFF58},
	{0x2DBD95, 0x245DF8, 0x228DDF, 0x1E2788},
	{0x2D8FA4, 0x241DAC, 0x224D24, 0x1DDF86},
	{0x2DA2F7, 0x243B5E, 0x226DF2, 0x1E078F},
	{0x2D7466, 0x23FA43, 0x222C70, 0x1DBEB3},
	{0x2D87B0, 0x2417DF, 0x224D20, 0x1DE695},
	{0x2D587E, 0x23D5F4, 0x220AD8, 0x1D9CE3},
	{0x2D6BBE, 0x23F37A, 0x222B6B, 0x1DC49C},
	{0x2D3BEA, 0x23B0C0, 0x21E85F, 0x1D7A17},
	{0x2D4F20, 0x23CE2C, 0x2208CE, 0x1DA1A1},
	{0x2D1EAB, 0x238AA7, 0x21C505, 0x1D5652},
	{0x2D31D6, 0x23A7FB, 0x21E553, 0x1D7DAF},
	{0x2D00BC, 0x2363A4, 0x21A0C5, 0x1D318D},
	{0x2D13DD, 0x2380DF, 0x21C0F1, 0x1D58BC},
	{0x2D2702, 0x239E2D, 0x21E13E, 0x1D8024},
	{0x2CF531, 0x2358D6, 0x219BA7, 0x1D32C6},
	{0x2D084D, 0x23760C, 0x21BBD2, 0x1D5A00},
	{0x2CD5D2, 0x232FE0, 0x217574, 0x1D0BD0},
	{0x2CE8E2, 0x234CFB, 0x21957B, 0x1D32D7},
	{0x2CB5BC, 0x2305FA, 0x214E59, 0x1CE3D8},
	{0x2CC8C2, 0x2322FB, 0x216E3B, 0x1D0AAD},
	{0x2C94EE, 0x22DB23, 0x212653, 0x1CBADD},
	{0x2CA7E9, 0x22F809, 0x21460F, 0x1CE17E},
	{0x2CBAE8, 0x231500, 0x2165EC, 0x1D0858},
	{0x2C8655, 0x22CC23, 0x211CF8, 0x1CB74C},
	{0x2C9949, 0x22E8FF, 0x213CAE, 0x1CDDEF},
	{0x2C6406, 0x229F48, 0x20F2F4, 0x1C8C17},
	{0x2C76EE, 0x22BC07, 0x211282, 0x1CB282},
	{0x2C40F7, 0x227174, 0x20C801, 0x1C5FDB},
	{0x2C53D3, 0x228E17, 0x20E767, 0x1C860E},
	{0x2C66B4, 0x22AACC, 0x2106EC, 0x1CAC79},
	{0x2C2FF8, 0x225F2F, 0x20BB5E, 0x1C5896},
	{0x2C423A, 0x227AF8, 0x20D9EA, 0x1C7DDD},
	{0x2C0AC6, 0x222E7E, 0x208D97, 0x1C2931},
	{0x2C1D8F, 0x224AF7, 0x20ACC7, 0x1C4F25},
	{0x2C305D, 0x226781, 0x20CC19, 0x1C7551},
	{0x2BF81E, 0x2219F8, 0x207EB4, 0x1C1F67},
	{0x2C0ADE, 0x223663, 0x209DD8, 0x1C4553},
	{0x2BD1E4, 0x21E7F9, 0x204FAF, 0x1BEEA3},
	{0x2BE498, 0x220445, 0x206EA6, 0x1C144F},
	{0x2BAAE0, 0x21B4FA, 0x201FB7, 0x1BBCD9},
	{0x2BBD86, 0x21D124, 0x203E7F, 0x1BE242},
	{0x2BD031, 0x21ED61, 0x205D67, 0x1C07E4},
	{0x2B95A9, 0x219D05, 0x200D69, 0x1BAF35},
	{0x2BA848, 0x21B922, 0x202C25, 0x1BD496},
	{0x2B6CFD, 0x2167E1, 0x1FDB61, 0x1B7B24},
	{0x2B7F8E, 0x2183DC, 0x1FF9EB, 0x1BA03E},
	{0x2B9224, 0x219FE8, 0x201895, 0x1BC590},
	{0x2B5600, 0x214D8E, 0x1FC6BB, 0x1B6ADF},
	{0x2B6889, 0x216978, 0x1FE534, 0x1B8FEB},
	{0x2B2BA1, 0x21163C, 0x1F929B, 0x1B3481},
	{0x2B3E1C, 0x213204, 0x1FB0E3, 0x1B5946},
	{0x2B5132, 0x214EAE, 0x1FD01A, 0x1B7F2B},
	{0x2B136D, 0x20FA53, 0x1F7C69, 0x1B2280},
	{0x2B264E, 0x2116A3, 0x1F9B37, 0x1B47E0},
	{0x2B3856, 0x2131D3, 0x1FB8F3, 0x1B6C1F},
	{0x2AF9B4, 0x20DC5D, 0x1F642F, 0x1B0E3C},
	{0x2B0C1D, 0x20F803, 0x1F8250, 0x1B32DC},
	{0x2ACCAB, 0x20A1A1, 0x1F2CC7, 0x1AD43E},
	{0x2ADF0C, 0x20BD2B, 0x1F4ABC, 0x1AF89C},
	{0x2AF16A, 0x20D8BC, 0x1F68C7, 0x1B1D24},
	{0x2AB117, 0x20813E, 0x1F122D, 0x1ABD53},
	{0x2AC368, 0x209CAB, 0x1F3003, 0x1AE18F},
	{0x2A8240, 0x20443E, 0x1ED8A4, 0x1A8106},
	{0x2A9482, 0x205F85, 0x1EF642, 0x1AA4F2},
	{0x2AA6C8, 0x207ADD, 0x1F1400, 0x1AC913},
	{0x2A64B9, 0x202151, 0x1EBB92, 0x1A675C},
	{0x2A76F1, 0x203C83, 0x1ED917, 0x1A8B2C},
	{0x2A892D, 0x2057C6, 0x1EF6BB, 0x1AAF30},
	{0x2A4631, 0x1FFD13, 0x1E9D36, 0x1A4C43},
	{0x2A585E, 0x20182E, 0x1EBAA0, 0x1A6FF4},
	{0x2A6A8F, 0x20335B, 0x1ED828, 0x1A93DA},
	{0x2A26A3, 0x1FD77F, 0x1E7D8C, 0x1A2FB6},
	{0x2A38C5, 0x1FF284, 0x1E9ADB, 0x1A5348},
	{0x2A4AEB, 0x200D99, 0x1EB848, 0x1A770D},
	{0x2A060F, 0x1FB097, 0x1E5C99, 0x1A11BC},
	{0x2A1825, 0x1FCB82, 0x1E79C9, 0x1A3529},
	{0x2A2A3F, 0x1FE67F, 0x1E9717, 0x1A58CB},
	{0x29E470, 0x1F8856, 0x1E3A57, 0x19F24F},
	{0x29F67A, 0x1FA328, 0x1E5768, 0x1A1597},
	{0x2A0889, 0x1FBE0C, 0x1E7497, 0x1A3913},
	{0x29C1C1, 0x1F5EB6, 0x1E16C1, 0x19D168},
	{0x29D3C0, 0x1F7970, 0x1E33B3, 0x19F48A},
	{0x298C12, 0x1F1926, 0x1DD524, 0x198C43},
	{0x299D7F, 0x1F3304, 0x1DF125, 0x19AE41},
	{0x29AF71, 0x1F4DA2, 0x1E0DF4, 0x19D138},
	{0x29C168, 0x1F6851, 0x1E2AE1, 0x19F463},
	{0x2978A6, 0x1F069F, 0x1DCAE5, 0x198A66},
	{0x298A8C, 0x1F2122, 0x1DE791, 0x19AD32},
	{0x2940D6, 0x1EBE6F, 0x1D86D4, 0x194293},
	{0x2952AA, 0x1ED8C6, 0x1DA33F, 0x1964FF},
	{0x29650A, 0x1EF3E7, 0x1DC080, 0x19886D},
	{0x2976F1, 0x1F0E6B, 0x1DDD33, 0x19AB4F},
	{0x292C2B, 0x1EAA58, 0x1D7B12, 0x193F06},
	{0x293DF8, 0x1EC4A4, 0x1D9777, 0x196179},
	{0x294FC9, 0x1EDEFF, 0x1DB3F8, 0x19841D},
	{0x2903FD, 0x1E79B9, 0x1D50C7, 0x1916B4},
	{0x2915BC, 0x1E93E7, 0x1D6D05, 0x1938F5},
	{0x29277F, 0x1EAE24, 0x1D895E, 0x195B66},
	{0x28DAA8, 0x1E47AA, 0x1D251E, 0x18ECE1},
	{0x28EC5A, 0x1E61B9, 0x1D4133, 0x190EED},
	{0x28FE10, 0x1E7BD8, 0x1D5D66, 0x19312C},
	{0x28B02B, 0x1E1429, 0x1CF816, 0x18C18D},
	{0x28C1CF, 0x1E2E1A, 0x1D1404, 0x18E365},
	{0x28D378, 0x1E481B, 0x1D300E, 0x190570},
	{0x288482, 0x1DDF36, 0x1CC9B3, 0x1894BC},
	{0x289619, 0x1DF907, 0x1CE577, 0x18B65D},
	{0x28A7B2, 0x1E12E5, 0x1D0154, 0x18D82C},
	{0x2857A8, 0x1DA8CA, 0x1C99EE, 0x186668},
	{0x286930, 0x1DC279, 0x1CB585, 0x1887CE},
	{0x287ABC, 0x1DDC38, 0x1CD138, 0x18A965},
	{0x288C4C, 0x1DF606, 0x1CED07, 0x18CB2E},
	{0x283B12, 0x1D8A70, 0x1C8431, 0x1857BB},
	{0x284C90, 0x1DA40D, 0x1C9FB7, 0x187917},
	{0x285E12, 0x1DBDBA, 0x1CBB58, 0x189AA4},
	{0x280BBE, 0x1D50ED, 0x1C517E, 0x18262C},
	{0x281D2C, 0x1D6A68, 0x1C6CD5, 0x184749},
	{0x282E9E, 0x1D83F1, 0x1C8847, 0x186896},
	{0x27DB2A, 0x1D15E7, 0x1C1D64, 0x17F315},
	{0x27EC89, 0x1D2F3D, 0x1C3889, 0x1813F0},
	{0x27FDEB, 0x1D48A2, 0x1C53CB, 0x1834FC},
	{0x280F57, 0x1D621E, 0x1C6F31, 0x185643},
	{0x27BAA6, 0x1CF292, 0x1C02DD, 0x17DF1A},
	{0x27CBF9, 0x1D0BD4, 0x1C1DEE, 0x17FFE4},
	{0x27DD51, 0x1D2524, 0x1C391A, 0x1820DE},
	{0x27877B, 0x1CB45F, 0x1BCBC8, 0x17A8BE},
	{0x2798BF, 0x1CCD7B, 0x1BE6A6, 0x17C943},
	{0x27AA07, 0x1CE6A6, 0x1C019F, 0x17E9F7},
	{0x27BB52, 0x1CFFE0, 0x1C1CB4, 0x180ADC},
	{0x27643C, 0x1C8D9E, 0x1BADFC, 0x179125},
	{0x2775F2, 0x1CA746, 0x1BC95F, 0x17B240},
	{0x2786AE, 0x1CBFB3, 0x1BE39E, 0x17D22A},
	{0x272E6A, 0x1C4C34, 0x1B73EB, 0x175784},
	{0x273F90, 0x1C650F, 0x1B8E77, 0x1777A5},
	{0x2750BC, 0x1C7DFD, 0x1BA922, 0x1797F8},
	{0x2761EA, 0x1C96F6, 0x1BC3E5, 0x17B878},
	{0x27085B, 0x1C21F2, 0x1B52CB, 0x173C3D},
	{0x271974, 0x1C3AB4, 0x1B6D3B, 0x175C40},
	{0x272A91, 0x1C5386, 0x1B87C7, 0x177C73},
	{0x26CFCE, 0x1BDD44, 0x1B15B7, 0x16FF56},
	{0x26E0D6, 0x1BF5DE, 0x1B2FF0, 0x171F0C},
	{0x26F1E3, 0x1C0E88, 0x1B4A44, 0x173EF2},
	{0x2702F4, 0x1C2740, 0x1B64B2, 0x175F06},
	{0x26A6DB, 0x1BAF75, 0x1AF13E, 0x16E05C},
	{0x26B7D7, 0x1BC7F5, 0x1B0B57, 0x16FFF0},
	{0x26C8D6, 0x1BE082, 0x1B258B, 0x171FB3},
	{0x26D9D8, 0x1BF91C, 0x1B3FD7, 0x173FA3},
	{0x267C69, 0x1B7FCD, 0x1ACB04, 0x16BF75},
	{0x268D56, 0x1B982E, 0x1AE4FB, 0x16DEE3},
	{0x269E47, 0x1BB09F, 0x1AFF0D, 0x16FE80},
	{0x263F96, 0x1B360F, 0x1A894E, 0x167D84},
	{0x265072, 0x1B4E47, 0x1AA309, 0x169C9D},
	{0x266151, 0x1B668C, 0x1ABCDD, 0x16BBE4},
	{0x267234, 0x1B7EDF, 0x1AD6CD, 0x16DB5A},
	{0x26831A, 0x1B9741, 0x1AF0D5, 0x16FAFE},
	{0x2622EF, 0x1B1ADE, 0x1A7949, 0x1677D3},
	{0x2633C0, 0x1B3305, 0x1A92F8, 0x1696F0},
	{0x264494, 0x1B4B39, 0x1AACC2, 0x16B63A},
	{0x25E31E, 0x1ACD97, 0x1A3451, 0x163252},
	{0x25F3DC, 0x1AE58F, 0x1A4DC0, 0x165113},
	{0x26049D, 0x1AFD95, 0x1A6749, 0x167001},
	{0x261561, 0x1B15AA, 0x1A80EB, 0x168F1E},
	{0x25B283, 0x1A967D, 0x1A0725, 0x1609C8},
	{0x25C331, 0x1AAE54, 0x1A206C, 0x162859},
	{0x25D3E2, 0x1AC63A, 0x1A39CC, 0x164717},
	{0x25E497, 0x1ADE2D, 0x1A5346, 0x166602},
	{0x25804B, 0x1A5D75, 0x19D82F, 0x15DF47},
	{0x2590E9, 0x1A752A, 0x19F14C, 0x15FDA5},
	{0x25A18A, 0x1A8CED, 0x1A0A81, 0x161C2F},
	{0x25B22F, 0x1AA4BD, 0x1A23CF, 0x163AE5},
	{0x254C70, 0x1A227A, 0x19A76C, 0x15B2CC},
	{0x255CFF, 0x1A3A0E, 0x19C05E, 0x15D0F6},
	{0x256D91, 0x1A51AF, 0x19D968, 0x15EF4B},
	{0x257E26, 0x1A695D, 0x19F28B, 0x160DCD},
	{0x2516EF, 0x19E58D, 0x1974DE, 0x15845C},
	{0x25276C, 0x19FCFC, 0x198DA1, 0x15A24B},
	{0x2537ED, 0x1A1478, 0x19A67D, 0x15C067},
	{0x254871, 0x1A2C01, 0x19BF72, 0x15DEAF},
	{0x2558F9, 0x1A4398, 0x19D87F, 0x15FD23},
	{0x24F02B, 0x19BDEF, 0x195914, 0x1571A5},
	{0x25009C, 0x19D547, 0x1971C2, 0x158F86},
	{0x25110F, 0x19ECAC, 0x198A88, 0x15AD93},
	{0x252186, 0x1A041D, 0x19A366, 0x15CBCB},
	{0x24B735, 0x197CE6, 0x1922B7, 0x153F03},
	{0x24C794, 0x199416, 0x193B32, 0x155CA4},
	{0x24D7F6, 0x19AB54, 0x1953C6, 0x157A71},
	{0x24E85B, 0x19C2A0, 0x196C73, 0x15986B},
	{0x247C84, 0x1939DD, 0x18EA89, 0x150A68},
	{0x248CD3, 0x1950E8, 0x1902D3, 0x1527CA},
	{0x249D23, 0x1967FE, 0x191B35, 0x154556},
	{0x24AD77, 0x197F22, 0x1933AE, 0x15630D},
	{0x24BDCE, 0x199653, 0x194C40, 0x1580F0},
	{0x245050, 0x190BB4, 0x18C8A1, 0x14F0F3},
	{0x24608E, 0x1922A2, 0x18E0CE, 0x150E3A},
	{0x2470D0, 0x19399E, 0x18F913, 0x152BAD},
	{0x248115, 0x1950A6, 0x19116F, 0x15494B},
	{0x241205, 0x18C47A, 0x188C9D, 0x14B822},
	{0x242231, 0x18DB3E, 0x18A494, 0x14D523},
	{0x243260, 0x18F210, 0x18BCA2, 0x14F24E},
	{0x244293, 0x1908EF, 0x18D4C8, 0x150FA5},
	{0x23D1EC, 0x187B36, 0x184EC9, 0x147D5C},
	{0x23E206, 0x1891D1, 0x186688, 0x149A13},
	{0x23F222, 0x18A878, 0x187E5E, 0x14B6F4},
	{0x240242, 0x18BF2B, 0x18964B, 0x14D400},
	{0x241265, 0x18D5EC, 0x18AE51, 0x14F136},
	{0x23A006, 0x184657, 0x1826AC, 0x145D0F},
	{0x23B00F, 0x185CD2, 0x183E47, 0x1479A2},
	{0x23C01C, 0x18735A, 0x1855FB, 0x149660},
	{0x23D02C, 0x1889EE, 0x186DC5, 0x14B349},
	{0x235C2B, 0x17F8D0, 0x17E501, 0x141E1A},
	{0x236C21, 0x180F1E, 0x17FC61, 0x143A5E},
	{0x237C1A, 0x182578, 0x1813D8, 0x1456CB},
	{0x238C16, 0x183BDF, 0x182B67, 0x147363},
	{0x239C15, 0x185253, 0x18430D, 0x149024},
	{0x232650, 0x17BF58, 0x17B8AC, 0x13F92B},
	{0x233635, 0x17D585, 0x17CFE6, 0x141545},
	{0x23461D, 0x17EBBD, 0x17E736, 0x143189},
	{0x235608, 0x180203, 0x17FE9E, 0x144DF6},
	{0x2365F7, 0x181854, 0x18161D, 0x146A8D},
	{0x22EE67, 0x17837C, 0x178A26, 0x13D1D2},
	{0x22FE3B, 0x179986, 0x17A137, 0x13EDBF},
	{0x230E12, 0x17AF9C, 0x17B85F, 0x1409D6},
	{0x231DEC, 0x17C5BE, 0x17CF9E, 0x142616},
	{0x232DC9, 0x17DBEE, 0x17E6F4, 0x144281},
	{0x22B469, 0x17453B, 0x17596F, 0x13A813},
	{0x22C42C, 0x175B20, 0x177055, 0x13C3D0},
	{0x22D3F1, 0x177112, 0x178752, 0x13DFB6},
	{0x22E3B9, 0x178710, 0x179E66, 0x13FBC5},
	{0x22F384, 0x179D1A, 0x17B591, 0x1417FD},
	{0x22784D, 0x17048B, 0x172681, 0x137BE4},
	{0x2287FC, 0x171A4B, 0x173D3A, 0x13976C},
	{0x2297AF, 0x173016, 0x175409, 0x13B31D},
	{0x22A766, 0x1745EF, 0x176AF1, 0x13CEF9},
	{0x222A70, 0x16ABDF, 0x16DAEA, 0x13321F},
	{0x223A0B, 0x16C16D, 0x16F15E, 0x134D49},
	{0x2249A9, 0x16D705, 0x1707E9, 0x13689B},
	{0x225949, 0x16ECAB, 0x171E8A, 0x138415},
	{0x2268EC, 0x17025C, 0x173541, 0x139FB7},
	{0x21EA12, 0x166672, 0x16A3BF, 0x13014F},
	{0x21F99B, 0x167BD8, 0x16BA03, 0x131C3E},
	{0x220925, 0x169149, 0x16D05D, 0x133756},
	{0x2218B3, 0x16A6C6, 0x16E6CD, 0x135295},
	{0x222843, 0x16BC4F, 0x16FD53, 0x136DFD},
	{0x21A77F, 0x161E8E, 0x166A60, 0x12CE15},
	{0x21B6F3, 0x1633CA, 0x168071, 0x12E8C6},
	{0x21C66B, 0x164912, 0x169698, 0x13039F},
	{0x21D5E5, 0x165E66, 0x16ACD5, 0x131EA0},
	{0x21E562, 0x1673C6, 0x16C327, 0x1339C9},
	{0x21F4E1, 0x168931, 0x16D990, 0x135519},
	{0x21720E, 0x15E942, 0x1644A8, 0x12B2E2},
	{0x218171, 0x15FE5F, 0x165A9A, 0x12CD7A},
	{0x2190D8, 0x161388, 0x1670A2, 0x12E839},
	{0x21A041, 0x1628BD, 0x1686BF, 0x13031F},
	{0x21AFAC, 0x163DFD, 0x169CF2, 0x131E2D},
	{0x212AE1, 0x159C3C, 0x1606AB, 0x127A96},
	{0x213A30, 0x15B12D, 0x161C66, 0x1294E8},
	{0x214982, 0x15C62A, 0x163236, 0x12AF62},
	{0x2158D7, 0x15DB32, 0x16481B, 0x12CA02},
	{0x21682E, 0x15F046, 0x165E16, 0x12E4CA},
	{0x217788, 0x160565, 0x167427, 0x12FFB9},
	{0x20F09F, 0x156179, 0x15DBFC, 0x1259EE},
	{0x20FFDC, 0x157649, 0x15F193, 0x12741F},
	{0x210F1C, 0x158B23, 0x16073E, 0x128E76},
	{0x211E5F, 0x15A009, 0x161CFF, 0x12A8F3},
	{0x212DA4, 0x15B4FB, 0x1632D6, 0x12C398},
	{0x20A4B5, 0x150F41, 0x159960, 0x121C90},
	{0x20B3DD, 0x1523E2, 0x15AEBB, 0x123674},
	{0x20C308, 0x15388D, 0x15C42A, 0x12507D},
	{0x20D235, 0x154D44, 0x15D9AF, 0x126AAD},
	{0x20E165, 0x156206, 0x15EF48, 0x128504},
	{0x205669, 0x14BA82, 0x155493, 0x11DCD1},
	{0x20657B, 0x14CEF2, 0x1569B0, 0x11F665},
	{0x207490, 0x14E36E, 0x157EE1, 0x12101E},
	{0x2083A7, 0x14F7F4, 0x159427, 0x1229FD},
	{0x2092C1, 0x150C86, 0x15A983, 0x124403},
	{0x20A1DE, 0x152123, 0x15BEF3, 0x125E2F},
	{0x2014AF, 0x14777C, 0x152278, 0x11B3FD},
	{0x2023AE, 0x148BC6, 0x15376A, 0x11CD62},
	{0x2032AF, 0x14A01B, 0x154C70, 0x11E6EE},
	{0x2041B4, 0x14B47B, 0x15618C, 0x12009F},
	{0x2050BA, 0x14C8E7, 0x1576BB, 0x121A76},
	{0x205FC3, 0x14DD5D, 0x158C00, 0x123474},
	{0x1FD056, 0x143192, 0x14EDC6, 0x11884E},
	{0x1FDF42, 0x1445B4, 0x15028B, 0x11A182},
	{0x1FEE2F, 0x1459E1, 0x151763, 0x11BADB},
	{0x1FFD1F, 0x146E1A, 0x152C50, 0x11D45A},
	{0x200C12, 0x14825D, 0x154152, 0x11EDFE},
	{0x201B06, 0x1496AB, 0x155668, 0x1207C9},
	{0x1F8957, 0x13E8C2, 0x14B67F, 0x1159C7},
	{0x1F982D, 0x13FCBB, 0x14CB13, 0x1172C5},
	{0x1FA706, 0x1410BF, 0x14DFBB, 0x118BE7},
	{0x1FB5E1, 0x1424CD, 0x14F477, 0x11A52F},
	{0x1FC4BF, 0x1438E7, 0x150948, 0x11BE9C},
	{0x1F30E5, 0x138945, 0x146853, 0x110FC7},
	{0x1F3FA4, 0x139D08, 0x147CA0, 0x112866},
	{0x1F4E66, 0x13B0D6, 0x149102, 0x114129},
	{0x1F5D29, 0x13C4AF, 0x14A577, 0x115A11},
	{0x1F6BF0, 0x13D892, 0x14BA00, 0x11731E},
	{0x1F7AB8, 0x13EC80, 0x14CE9E, 0x118C51},
	{0x1EE48B, 0x133AC8, 0x142C12, 0x10DBCA},
	{0x1EF334, 0x134E5F, 0x14402B, 0x10F42A},
	{0x1F01E0, 0x136201, 0x145457, 0x110CAF},
	{0x1F108F, 0x1375AD, 0x146898, 0x112559},
	{0x1F1F3F, 0x138964, 0x147CEC, 0x113E28},
	{0x1F2DF2, 0x139D25, 0x149154, 0x11571B},
	{0x1F3CA7, 0x13B0F1, 0x14A5D0, 0x117032},
	{0x1EA3FC, 0x12FCC5, 0x140120, 0x10BD17},
	{0x1EB292, 0x131039, 0x141516, 0x10D55A},
	{0x1EC12A, 0x1323B7, 0x14291E, 0x10EDC1},
	{0x1ECFC5, 0x133740, 0x143D3B, 0x11064C},
	{0x1EDE62, 0x134AD3, 0x14516B, 0x111EFC},
	{0x1EED01, 0x135E71, 0x1465AF, 0x1137D1},
	{0x1E51F2, 0x12A839, 0x13BF86, 0x108332},
	{0x1E6072, 0x12BB7D, 0x13D341, 0x109B2F},
	{0x1E6EF4, 0x12CECC, 0x13E710, 0x10B34F},
	{0x1E7D78, 0x12E225, 0x13FAF2, 0x10CB93},
	{0x1E8BFE, 0x12F589, 0x140EE8, 0x10E3FB},
	{0x1E9A87, 0x1308F7, 0x1422F1, 0x10FC88},
	{0x1DFD0A, 0x1250B7, 0x137B5C, 0x10467E},
	{0x1E0B73, 0x1263CA, 0x138EDB, 0x105E2F},
	{0x1E19DE, 0x1276E8, 0x13A26D, 0x107604},
	{0x1E284B, 0x128A10, 0x13B613, 0x108DFD},
	{0x1E36BA, 0x129D42, 0x13C9CB, 0x10A61A},
	{0x1E452B, 0x12B07E, 0x13DD97, 0x10BE5A},
	{0x1E539F, 0x12C3C5, 0x13F176, 0x10D6BE},
	{0x1DB38C, 0x120920, 0x1347EA, 0x101E66},
	{0x1DC1DF, 0x121C0B, 0x135B3E, 0x1035EC},
	{0x1DD034, 0x122F01, 0x136EA4, 0x104D96},
	{0x1DDE8C, 0x124200, 0x13821D, 0x106562},
	{0x1DECE6, 0x12550A, 0x1395AA, 0x107D53},
	{0x1DFB42, 0x12681E, 0x13A949, 0x109567},
	{0x1D58B0, 0x11AB7E, 0x12FE74, 0xFDBD9},
	{0x1D66EB, 0x11BE35, 0x131186, 0xFF30C},
	{0x1D7529, 0x11D0F7, 0x1324AA, 0x100A62},
	{0x1D8369, 0x11E3C2, 0x1337E2, 0x1021DB},
	{0x1D91AB, 0x11F697, 0x134B2D, 0x103977},
	{0x1D9FEF, 0x120977, 0x135E8A, 0x105137},
	{0x1DAE35, 0x121C60, 0x1371FA, 0x106919},
	{0x1D08F8, 0x115D67, 0x12C54D, 0xFAD71},
	{0x1D171E, 0x116FF3, 0x12D82E, 0xFC46F},
	{0x1D2545, 0x118288, 0x12EB22, 0xFDB90},
	{0x1D336E, 0x119528, 0x12FE28, 0xFF2D4},
	{0x1D419A, 0x11A7D1, 0x131141, 0x100A3A},
	{0x1D4FC7, 0x11BA84, 0x13246D, 0x1021C3},
	{0x1D5DF7, 0x11CD41, 0x1337AB, 0x103970},
	{0x1CB608, 0x110BF6, 0x128939, 0xF7BC9},
	{0x1CC416, 0x111E55, 0x129BE6, 0xF928E},
	{0x1CD226, 0x1130BD, 0x12AEA5, 0xFA975},
	{0x1CE039, 0x11432F, 0x12C177, 0xFC07F},
	{0x1CEE4D, 0x1155AA, 0x12D45C, 0xFD7AB},
	{0x1CFC64, 0x116830, 0x12E752, 0xFEEFA},
	{0x1D0A7C, 0x117ABF, 0x12FA5C, 0x10066B},
	{0x1C5FD1, 0x10B72A, 0x124A38, 0xF46E4},
	{0x1C6DC7, 0x10C959, 0x125CAE, 0xF5D6A},
	{0x1C7BC0, 0x10DB92, 0x126F36, 0xF7412},
	{0x1C89BB, 0x10EDD4, 0x1281D1, 0xF8ADD},
	{0x1C97B8, 0x110020, 0x12947E, 0xFA1CA},
	{0x1CA5B7, 0x111276, 0x12A73D, 0xFB8D9},
	{0x1CB3B8, 0x1124D5, 0x12BA0F, 0xFD00A},
	{0x1C0645, 0x105EFD, 0x12084C, 0xF0EC1},
	{0x1C1424, 0x1070FC, 0x121A89, 0xF2505},
	{0x1C2205, 0x108304, 0x122CD8, 0xF3B6A},
	{0x1C2FE8, 0x109515, 0x123F38, 0xF51F0},
	{0x1C3DCC, 0x10A730, 0x1251AB, 0xF6899},
	{0x1C4BB3, 0x10B955, 0x126430, 0xF7F64},
	{0x1C599C, 0x10CB83, 0x1276C7, 0xF9650},
	{0x1BA95B, 0x100374, 0x11C37D, 0xED36B},
	{0x1BB721, 0x101540, 0x11D57E, 0xEE967},
	{0x1BC4E9, 0x102715, 0x11E791, 0xEFF84},
	{0x1BD2B4, 0x1038F4, 0x11F9B5, 0xF15C3},
	{0x1BE080, 0x104ADC, 0x120BEB, 0xF2C23},
	{0x1BEE4E, 0x105CCE, 0x121E33, 0xF42A4},
	{0x1BFC1E, 0x106EC9, 0x12308D, 0xF5947},
	{0x1C09F1, 0x1080CD, 0x1242F8, 0xF700D},
	{0x1B56B0, 0xFB622, 0x118D92, 0xEAA96},
	{0x1B645F, 0xFC7C3, 0x119F66, 0xEC066},
	{0x1B7210, 0xFD96E, 0x11B14B, 0xED657},
	{0x1B7FC4, 0xFEB22, 0x11C341, 0xEEC69},
	{0x1B8D79, 0xFFCDF, 0x11D54A, 0xF029D},
	{0x1B9B30, 0x100EA5, 0x11E763, 0xF18F2},
	{0x1BA8E9, 0x102075, 0x11F98F, 0xF2F69},
	{0x1AF2C4, 0xF53A5, 0x1142CE, 0xE689B},
	{0x1B005A, 0xF6511, 0x115460, 0xE7E1A},
	{0x1B0DF2, 0xF7686, 0x116604, 0xE93BA},
	{0x1B1B8B, 0xF8803, 0x1177B8, 0xEA97A},
	{0x1B2927, 0xF998A, 0x11897E, 0xEBF5B},
	{0x1B36C4, 0xFAB1A, 0x119B55, 0xED55D},
	{0x1B4463, 0xFBCB3, 0x11AD3D, 0xEEB80},
	{0x1B5204, 0xFCE55, 0x11BF37, 0xF01C4},
	{0x1A98CD, 0xEFF00, 0x11068A, 0xE38AF},
	{0x1AA64A, 0xF103D, 0x1117E9, 0xE4DF8},
	{0x1AB3CA, 0xF2183, 0x112958, 0xE6361},
	{0x1AC14B, 0xF32D2, 0x113AD9, 0xE78EB},
	{0x1ACECE, 0xF442A, 0x114C6B, 0xE8E95},
	{0x1ADC53, 0xF558B, 0x115E0E, 0xEA460},
	{0x1AE9D9, 0xF66F4, 0x116FC1, 0xEBA4B},
	{0x1AF762, 0xF7868, 0x118187, 0xED058},
	{0x1A3B0D, 0xEA697, 0x10C706, 0xE051F},
	{0x1A4871, 0xEB7A3, 0x10D82D, 0xE1A2C},
	{0x1A55D7, 0xEC8B9, 0x10E966, 0xE2F5A},
	{0x1A6340, 0xED9D7, 0x10FAB0, 0xE44A8},
	{0x1A70AA, 0xEEAFF, 0x110C0B, 0xE5A16},
	{0x1A7E16, 0xEFC2F, 0x111D77, 0xE6FA5},
	{0x1A8B84, 0xF0D68, 0x112EF3, 0xE8553},
	{0x1A98F3, 0xF1EA9, 0x114081, 0xE9B23},
	{0x19D976, 0xE4A6B, 0x108447, 0xDCDF1},
	{0x19E6C1, 0xE5B46, 0x109536, 0xDE2BE},
	{0x19F40F, 0xE6C29, 0x10A635, 0xDF7AB},
	{0x1A015D, 0xE7D15, 0x10B745, 0xE0CB8},
	{0x1A0EAE, 0xE8E0A, 0x10C866, 0xE21E4},
	{0x1A1C01, 0xE9F07, 0x10D997, 0xE3731},
	{0x1A2955, 0xEB00D, 0x10EAD9, 0xE4C9D},
	{0x1966CB, 0xDD9E0, 0x102DB3, 0xD7EC2},
	{0x1973FA, 0xDEA7D, 0x103E55, 0xD932A},
	{0x19812C, 0xDFB24, 0x104F07, 0xDA7B1},
	{0x198E5F, 0xE0BD3, 0x105FCA, 0xDBC57},
	{0x199B93, 0xE1C8A, 0x10709D, 0xDD11D},
	{0x19A8CA, 0xE2D4A, 0x108180, 0xDE602},
	{0x19B602, 0xE3E13, 0x109274, 0xDFB08},
	{0x19C33C, 0xE4EE4, 0x10A378, 0xE102D},
	{0x19D078, 0xE5FBF, 0x10B48E, 0xE2572},
	{0x190A8A, 0xD86CF, 0xFF538, 0xD54D2},
	{0x1917A0, 0xD973F, 0x1005AB, 0xD690E},
	{0x1924B9, 0xDA7B8, 0x10162D, 0xD7D68},
	{0x1931D3, 0xDB839, 0x1026C0, 0xD91E2},
	{0x193EEF, 0xDC8C3, 0x103763, 0xDA67B},
	{0x194C0D, 0xDD955, 0x104817, 0xDBB34},
	{0x19592C, 0xDE9F0, 0x1058DB, 0xDD00C},
	{0x19664D, 0xDFA94, 0x1069AF, 0xDE503},
	{0x189D16, 0xD1F63, 0xFA8FB, 0xD12F5},
	{0x18AA12, 0xD2F9C, 0xFB92B, 0xD26E1},
	{0x18B70F, 0xD3FDD, 0xFC96B, 0xD3AEB},
	{0x18C40E, 0xD5026, 0xFD9BB, 0xD4F13},
	{0x18D10F, 0xD6078, 0xFEA1B, 0xD635A},
	{0x18DE11, 0xD70D2, 0xFFA8C, 0xD77C1},
	{0x18EB15, 0xD8134, 0x100B0C, 0xD8C46},
	{0x18F81B, 0xD919F, 0x101B9C, 0xDA0EB},
	{0x190522, 0xDA213, 0x102C3D, 0xDB5AF},
	{0x183870, 0xCC43E, 0xF6996, 0xCE138},
	{0x184551, 0xCD445, 0xF7990, 0xCF4EB},
	{0x185235, 0xCE455, 0xF899A, 0xD08BE},
	{0x185F19, 0xCF46C, 0xF99B4, 0xD1CAE},
	{0x186C00, 0xD048D, 0xFA9DE, 0xD30BD},
	{0x1878E8, 0xD14B5, 0xFBA18, 0xD44EA},
	{0x1885D2, 0xD24E6, 0xFCA62, 0xD5937},
	{0x1892BE, 0xD351F, 0xFDABB, 0xD6DA3},
	{0x189FAB, 0xD4560, 0xFEB24, 0xD822D},
	{0x17CF72, 0xC64FA, 0xF26AE, 0xCAB82},
	{0x17DC39, 0xC74CE, 0xF366F, 0xCBEF8},
	{0x17E902, 0xC84AA, 0xF4640, 0xCD28C},
	{0x17F5CC, 0xC948E, 0xF5621, 0xCE63F},
	{0x180298, 0xCA47B, 0xF6611, 0xCFA0F},
	{0x180F66, 0xCB46F, 0xF7611, 0xD0DFE},
	{0x181C35, 0xCC46C, 0xF8621, 0xD220C},
	{0x182905, 0xCD471, 0xF9640, 0xD3638},
	{0x1835D7, 0xCE47E, 0xFA66F, 0xD4A82},
	{0x17620D, 0xC0198, 0xEE04B, 0xC71D6},
	{0x176EB8, 0xC1137, 0xEEFD0, 0xC8509},
	{0x177B66, 0xC20DE, 0xEFF64, 0xC9859},
	{0x178815, 0xC308C, 0xF0F08, 0xCABC7},
	{0x1794C5, 0xC4043, 0xF1EBB, 0xCBF53},
	{0x17A177, 0xC5002, 0xF2E7E, 0xCD2FD},
	{0x17AE2B, 0xC5FC9, 0xF3E50, 0xCE6C6},
	{0x17BAE0, 0xC6F98, 0xF4E32, 0xCFAAD},
	{0x17C797, 0xC7F6F, 0xF5E23, 0xD0EB2},
	{0x16F02E, 0xB9A1D, 0xE9677, 0xC343E},
	{0x16FCBE, 0xBA985, 0xEA5BD, 0xC4727},
	{0x17094F, 0xBB8F4, 0xEB511, 0xC5A2E},
	{0x1715E2, 0xBC86C, 0xEC475, 0xC6D52},
	{0x172277, 0xBD7EB, 0xED3E9, 0xC8094},
	{0x172F0D, 0xBE772, 0xEE36B, 0xC93F3},
	{0x173BA4, 0xBF701, 0xEF2FC, 0xCA770},
	{0x17483E, 0xC0698, 0xF029D, 0xCBB0C},
	{0x1754D8, 0xC1637, 0xF124D, 0xCCEC5},
	{0x1679C7, 0xB2E91, 0xE4943, 0xBF2CA},
	{0x16863A, 0xB3DBF, 0xE5846, 0xC0564},
	{0x1692AF, 0xB4CF5, 0xE6758, 0xC181B},
	{0x169F25, 0xB5C33, 0xE7678, 0xC2AEF},
	{0x16AB9D, 0xB6B79, 0xE85A8, 0xC3DE0},
	{0x16B817, 0xB7AC6, 0xE94E6, 0xC50EE},
	{0x16C492, 0xB8A1B, 0xEA433, 0xC641A},
	{0x16D10E, 0xB9978, 0xEB390, 0xC7764},
	{0x16DD8C, 0xBA8DD, 0xEC2FB, 0xC8ACB},
	{0x16EA0B, 0xBB84A, 0xED276, 0xC9E51},
	{0x160B1C, 0xACDED, 0xE077B, 0xBBFCE},
	{0x161773, 0xADCE8, 0xE1646, 0xBD22F},
	{0x1623CD, 0xAEBEA, 0xE2520, 0xBE4AD},
	{0x163027, 0xAFAF4, 0xE3409, 0xBF747},
	{0x163C84, 0xB0A06, 0xE4300, 0xC09FF},
	{0x1648E1, 0xB191F, 0xE5206, 0xC1CD4},
	{0x165540, 0xB2840, 0xE611B, 0xC2FC6},
	{0x1661A1, 0xB3769, 0xE703F, 0xC42D6},
	{0x166E03, 0xB469A, 0xE7F72, 0xC5602},
	{0x158B54, 0xA5A1A, 0xDB371, 0xB767D},
	{0x15978E, 0xA68D8, 0xDC1F3, 0xB8882},
	{0x15A3C9, 0xA779D, 0xDD083, 0xB9AA4},
	{0x15B006, 0xA8669, 0xDDF22, 0xBACE3},
	{0x15BC45, 0xA953D, 0xDEDCF, 0xBBF3E},
	{0x15C884, 0xAA419, 0xDFC8B, 0xBD1B6},
	{0x15D4C6, 0xAB2FC, 0xE0B55, 0xBE44A},
	{0x15E108, 0xAC1E7, 0xE1A2E, 0xBF6FC},
	{0x15ED4D, 0xAD0D9, 0xE2916, 0xC09CA},
	{0x15F993, 0xADFD3, 0xE380C, 0xC1CB6},
	{0x1512ED, 0x9F0D1, 0xD6A74, 0xB3B30},
	{0x151F0A, 0x9FF57, 0xD78B8, 0xB4CF1},
	{0x152B29, 0xA0DE4, 0xD870A, 0xB5ECD},
	{0x153749, 0xA1C79, 0xD956A, 0xB70C6},
	{0x15436B, 0xA2B15, 0xDA3D8, 0xB82DB},
	{0x154F8E, 0xA39B9, 0xDB255, 0xB950C},
	{0x155BB2, 0xA4864, 0xDC0E0, 0xBA75A},
	{0x1567D8, 0xA5716, 0xDCF7A, 0xBB9C4},
	{0x1573FF, 0xA65D0, 0xDDE21, 0xBCC4B},
	{0x158028, 0xA7491, 0xDECD7, 0xBDEEF},
	{0x158C52, 0xA835A, 0xDFB9C, 0xBF1B0},
	{0x14A180, 0x99173, 0xD2BDA, 0xB0D26},
	{0x14AD81, 0x99FC7, 0xD39EA, 0xB1EB6},
	{0x14B984, 0x9AE22, 0xD4808, 0xB3062},
	{0x14C587, 0x9BC83, 0xD5634, 0xB422A},
	{0x14D18D, 0x9CAED, 0xD646E, 0xB540E},
	{0x14DD94, 0x9D95D, 0xD72B6, 0xB660E},
	{0x14E99C, 0x9E7D5, 0xD810C, 0xB782B},
	{0x14F5A5, 0x9F655, 0xD8F71, 0xB8A64},
	{0x1501B0, 0xA04DB, 0xD9DE4, 0xB9CB9},
	{0x150DBD, 0xA1369, 0xDAC64, 0xBAF2B},
	{0x141EDD, 0x91F3A, 0xCDB6F, 0xAC935},
	{0x142AC0, 0x92D51, 0xCE939, 0xADA73},
	{0x1436A5, 0x93B70, 0xCF711, 0xAEBCC},
	{0x14428A, 0x94996, 0xD04F7, 0xAFD41},
	{0x144E72, 0x957C3, 0xD12EB, 0xB0ED1},
	{0x145A5A, 0x965F7, 0xD20ED, 0xB207D},
	{0x146644, 0x97433, 0xD2EFD, 0xB3245},
	{0x147230, 0x98275, 0xD3D1B, 0xB4429},
	{0x147E1C, 0x990BF, 0xD4B46, 0xB562A},
	{0x148A0A, 0x99F10, 0xD5980, 0xB6846},
	{0x1495FA, 0x9AD69, 0xD67C8, 0xB7A7F},
	{0x13A2D5, 0x8B692, 0xC950F, 0xA921C},
	{0x13AE9B, 0x8C473, 0xCA29E, 0xAA31C},
	{0x13BA62, 0x8D25B, 0xCB03B, 0xAB437},
	{0x13C62B, 0x8E049, 0xCBDE6, 0xAC56E},
	{0x13D1F5, 0x8EE3F, 0xCCB9E, 0xAD6BF},
	{0x13DDC0, 0x8FC3C, 0xCD963, 0xAE82C},
	{0x13E98C, 0x90A40, 0xCE737, 0xAF9B4},
	{0x13F55A, 0x9184B, 0xCF518, 0xB0B58},
	{0x140129, 0x9265D, 0xD0306, 0xB1D18},
	{0x140CF9, 0x93476, 0xD1103, 0xB2EF4},
	{0x1418CB, 0x94296, 0xD1F0E, 0xB40ED},
	{0x132156, 0x8493B, 0xC4ACA, 0xA5670},
	{0x132CFE, 0x856E2, 0xC581A, 0xA672B},
	{0x1338A7, 0x86491, 0xC6578, 0xA7800},
	{0x134452, 0x87246, 0xC72E3, 0xA88F1},
	{0x134FFD, 0x88003, 0xC805B, 0xA99FD},
	{0x135BAB, 0x88DC6, 0xC8DE1, 0xAAB23},
	{0x136759, 0x89B90, 0xC9B75, 0xABC66},
	{0x137309, 0x8A962, 0xCA916, 0xACDC3},
	{0x137EBA, 0x8B73A, 0xCB6C4, 0xADF3C},
	{0x138A6C, 0x8C519, 0xCC480, 0xAF0D0},
	{0x139620, 0x8D2FF, 0xCD24A, 0xB0281},
	{0x129A4E, 0x7D743, 0xBFCB5, 0xA1642},
	{0x12A5D7, 0x7E4AF, 0xC09C3, 0xA26B1},
	{0x12B161, 0x7F222, 0xC16DE, 0xA373A},
	{0x12BCED, 0x7FF9C, 0xC2405, 0xA47DD},
	{0x12C87A, 0x80D1C, 0xC313B, 0xA589C},
	{0x12D409, 0x81AA4, 0xC3E7D, 0xA6975},
	{0x12DF98, 0x82833, 0xC4BCD, 0xA7A6A},
	{0x12EB29, 0x835C8, 0xC5929, 0xA8B79},
	{0x12F6BC, 0x84364, 0xC6694, 0xA9CA3},
	{0x13024F, 0x85107, 0xC740B, 0xAADE9},
	{0x130DE4, 0x85EB1, 0xC8190, 0xABF4A},
	{0x120DAA, 0x760BB, 0xBAAEC, 0x9D1A9},
	{0x121914, 0x76DEA, 0xBB7B3, 0x9E1C5},
	{0x12247F, 0x77B1F, 0xBC487, 0x9F1FB},
	{0x122FEC, 0x7885B, 0xBD168, 0xA024A},
	{0x123B59, 0x7959E, 0xBDE56, 0xA12B4},
	{0x1246C8, 0x7A2E8, 0xBEB51, 0xA2339},
	{0x125239, 0x7B038, 0xBF859, 0xA33D7},
	{0x125DAA, 0x7BD8F, 0xC056E, 0xA4491},
	{0x12691D, 0x7CAED, 0xC1290, 0xA5566},
	{0x127491, 0x7D851, 0xC1FBF, 0xA6656},
	{0x128007, 0x7E5BD, 0xC2CFC, 0xA7760},
	{0x128B7D, 0x7F32F, 0xC3A46, 0xA8886},
	{0x1186A3, 0x6F2A7, 0xB6207, 0x99884},
	{0x1191EF, 0x6FF9D, 0xB6E91, 0x9A85F},
	{0x119D3B, 0x70C99, 0xB7B28, 0x9B854},
	{0x11A889, 0x7199C, 0xB87CB, 0x9C863},
	{0x11B3D8, 0x726A6, 0xB947C, 0x9D88C},
	{0x11BF29, 0x733B6, 0xBA139, 0x9E8CF},
	{0x11CA7B, 0x740CD, 0xBAE03, 0x9F92D},
	{0x11D5CE, 0x74DEA, 0xBBAD9, 0xA09A4},
	{0x11E122, 0x75B0E, 0xBC7BD, 0xA1A37},
	{0x11EC77, 0x76839, 0xBD4AD, 0xA2AE4},
	{0x11F7CE, 0x7756A, 0xBE1AB, 0xA3BAB},
	{0x120325, 0x782A2, 0xBEEB5, 0xA4C8E},
	{0x10F9A0, 0x67FB4, 0xB1521, 0x95A90},
	{0x1104CC, 0x68C6F, 0xB216A, 0x96A23},
	{0x110FFA, 0x69930, 0xB2DBF, 0x979CF},
	{0x111B28, 0x6A5F7, 0xB3A21, 0x98995},
	{0x112658, 0x6B2C5, 0xB468F, 0x99975},
	{0x113189, 0x6BF9A, 0xB530A, 0x9A96F},
	{0x113CBC, 0x6CC75, 0xB5F92, 0x9B983},
	{0x1147EF, 0x6D956, 0xB6C26, 0x9C9B0},
	{0x115324, 0x6E63E, 0xB78C7, 0x9D9F9},
	{0x115E5A, 0x6F32D, 0xB8575, 0x9EA5B},
	{0x116991, 0x70022, 0xB922F, 0x9FAD8},
	{0x1174CA, 0x70D1E, 0xB9EF6, 0xA0B70},
	{0x118003, 0x71A20, 0xBABCA, 0xA1C22},
	{0x10719A, 0x61475, 0xAD05A, 0x92725},
	{0x107CA8, 0x620F9, 0xADC6A, 0x93682},
	{0x1087B7, 0x62D83, 0xAE887, 0x945F8},
	{0x1092C7, 0x63A13, 0xAF4AF, 0x95587},
	{0x109DD8, 0x646A9, 0xB00E4, 0x96530},
	{0x10A8EB, 0x65346, 0xB0D26, 0x974F3},
	{0x10B3FE, 0x65FEA, 0xB1974, 0x984CF},
	{0x10BF13, 0x66C93, 0xB25CE, 0x994C4},
	{0x10CA29, 0x67943, 0xB3234, 0x9A4D4},
	{0x10D540, 0x685FA, 0xB3EA8, 0x9B4FE},
	{0x10E059, 0x692B7, 0xB4B28, 0x9C543},
	{0x10EB72, 0x69F7A, 0xB57B4, 0x9D5A2},
	{0xFD848, 0x597CA, 0xA7B84, 0x8DF87},
	{0xFE335, 0x5A40E, 0xA874B, 0x8EE8D},
	{0xFEE24, 0x5B058, 0xA931E, 0x8FDAB},
	{0xFF914, 0x5BCA8, 0xA9EFE, 0x90CE2},
	{0x100404, 0x5C8FF, 0xAAAE9, 0x91C33},
	{0x100EF6, 0x5D55C, 0xAB6E1, 0x92B9C},
	{0x1019E9, 0x5E1BE, 0xAC2E4, 0x93B1E},
	{0x1024DE, 0x5EE28, 0xACEF4, 0x94ABA},
	{0x102FD3, 0x5FA97, 0xADB10, 0x95A70},
	{0x103ACA, 0x6070D, 0xAE739, 0x96A40},
	{0x1045C2, 0x61389, 0xAF36E, 0x97A2A},
	{0x1050BB, 0x6200C, 0xAFFAF, 0x98A2D},
	{0x105BB5, 0x62C95, 0xB0BFD, 0x99A4B},
	{0xF4391, 0x5228F, 0xA2E8C, 0x8A219},
	{0xF4E5F, 0x52E97, 0xA3A12, 0x8B0D8},
	{0xF592D, 0x53AA5, 0xA45A4, 0x8BFAE},
	{0xF63FD, 0x546B9, 0xA5142, 0x8CE9E},
	{0xF6ECE, 0x552D3, 0xA5CEC, 0x8DDA7},
	{0xF79A0, 0x55EF4, 0xA68A2, 0x8ECC9},
	{0xF8474, 0x56B1B, 0xA7464, 0x8FC04},
	{0xF8F48, 0x57748, 0xA8032, 0x90B58},
	{0xF9A1E, 0x5837B, 0xA8C0B, 0x91AC5},
	{0xFA4F4, 0x58FB4, 0xA97F1, 0x92A4C},
	{0xFAFCC, 0x59BF3, 0xAA3E3, 0x939EC},
	{0xFBAA5, 0x5A839, 0xAAFE1, 0x949A6},
	{0xFC57F, 0x5B485, 0xABBEC, 0x9597A},
	{0xEA859, 0x4A861, 0x9DD8F, 0x85FAF},
	{0xEB306, 0x4B42B, 0x9E8D1, 0x86E1F},
	{0xEBDB4, 0x4BFFB, 0x9F41D, 0x87CA7},
	{0xEC863, 0x4CBD1, 0x9FF76, 0x88B48},
	{0xED314, 0x4D7AD, 0xA0ADB, 0x89A01},
	{0xEDDC6, 0x4E38F, 0xA164B, 0x8A8D3},
	{0xEE879, 0x4EF77, 0xA21C7, 0x8B7BE},
	{0xEF32C, 0x4FB66, 0xA2D4F, 0x8C6C1},
	{0xEFDE1, 0x5075A, 0xA38E2, 0x8D5DD},
	{0xF0898, 0x51354, 0xA4482, 0x8E512},
	{0xF134F, 0x51F54, 0xA502D, 0x8F461},
	{0xF1E08, 0x52B5B, 0xA5BE4, 0x903C9},
	{0xF28C1, 0x53768, 0xA67A8, 0x9134B},
	{0xF337C, 0x5437B, 0xA7377, 0x922E7},
	{0xE111B, 0x434EE, 0x993B1, 0x82689},
	{0xE1BA8, 0x4407D, 0x99EB6, 0x834BA},
	{0xE2636, 0x44C13, 0x9A9C5, 0x84303},
};

/*****************************************************
**				STV0367QAM routines
*****************************************************/
ST_Revision_t FE_367qam_GetLLARevision(void)
{
	return Revision367qam;
}

#ifdef CHIP_STAPI
#ifndef STFRONTEND_FORCE_STI2C_DEPRECATED
STCHIP_Error_t FE_367qam_Repeater(STCHIP_Handle_t hChip, BOOL State,
				  unsigned char *Buffer)
#else
STCHIP_Error_t FE_367qam_Repeater(STCHIP_Handle_t hChip, BOOL State)
#endif
#else
STCHIP_Error_t FE_367qam_Repeater(STCHIP_Handle_t hChip, BOOL State)
#endif
{
	STCHIP_Error_t error = CHIPERR_NO_ERROR;

	if (hChip != NULL) {
#ifdef CONFIG_ARCH_STI
		ChipSetField(hChip, F367qam_STOP_ENABLE, 0);
#endif
#ifdef CHIP_STAPI
#ifndef STFRONTEND_FORCE_STI2C_DEPRECATED
		error =
		    ChipFillRepeaterMessage(hChip, F367qam_I2CT_ON,
					    (State == TRUE) ? 1 : 0, Buffer);
#else
		error =
		    ChipSetField(hChip, F367qam_I2CT_ON,
				 (State == TRUE) ? 1 : 0);
#endif
#else
		error =
		    ChipSetField(hChip, F367qam_I2CT_ON,
				 (State == TRUE) ? 1 : 0);
#endif
	}
	return error;
}

/*****************************************************
**FUNCTION	::	FE_367qam_GetMclkFreq
**ACTION	::	Set the STV0367QAM master clock frequency
**PARAMS IN	::  hChip		==>	handle to the chip
**ExtClk_Hz	==>	External clock frequency(Hz)
**PARAMS OUT::	NONE
**RETURN	::	MasterClock frequency(Hz)
*****************************************************/
U32 FE_367qam_GetMclkFreq(STCHIP_Handle_t hChip, U32 ExtClk_Hz)
{
	U32 mclk_Hz = 0;	/* master clock frequency(Hz) */
	U32 M, N, P;

	if (ChipGetField(hChip, F367qam_BYPASS_PLLXN) == 0) {
		ChipGetRegisters(hChip, R367qam_PLLMDIV, 3);
		N = (U32) ChipGetFieldImage(hChip, F367qam_PLL_NDIV);
		if (N == 0)
			N = N + 1;
		M = (U32) ChipGetFieldImage(hChip, F367qam_PLL_MDIV);
		if (M == 0)
			M = M + 1;
		P = (U32) ChipGetFieldImage(hChip, F367qam_PLL_PDIV);

		if (P > 5)
			P = 5;
		mclk_Hz = ((ExtClk_Hz / 2) * N) / (M * PowOf2(P));
	} else
		mclk_Hz = ExtClk_Hz;
	return mclk_Hz;

}

/*****************************************************
**FUNCTION	::	FE_367qam_GetADCFreq
**ACTION	::	Get the STV0367QAM ADC clock frequency
**PARAMS IN	::  hChip		==>	handle to the chip
**ExtClk_Hz	==>	External clock frequency(Hz)
**PARAMS OUT::	NONE
**RETURN	::	ADC Clock frequency(Hz)
*****************************************************/
U32 FE_367qam_GetADCFreq(STCHIP_Handle_t hChip, U32 ExtClk_Hz)
{
	U32 ADCClk_Hz = ExtClk_Hz;

	ADCClk_Hz = FE_367qam_GetMclkFreq(hChip, ExtClk_Hz);

	return ADCClk_Hz;
}

/*****************************************************
**FUNCTION	::	FE_367qam_SetDerotFreq
**ACTION	::	Set the STV0367QAM derotator frequency
**PARAMS IN	::  hChip			==>	handle to the chip
**AdcClk_Hz	==>	ADC clock frequency(Hz)
**				DerotFreq_Hz	==>	Derotator frequency(Hz)
**PARAMS OUT::	NONE
**RETURN	::	DerotFreq_Hz
*****************************************************/
U32 FE_367qam_SetDerotFreq(STCHIP_Handle_t hChip, U32 AdcClk_Hz,
			   S32 DerotFreq_Hz)
{
	U32 Sampled_IF = 0;
	U32 AdcClk_kHz;

	AdcClk_kHz = AdcClk_Hz / 1000;

	if (AdcClk_kHz != 0) {
		if (DerotFreq_Hz < 1000000)
			DerotFreq_Hz = AdcClk_Hz / 4;	/* ZIF operation */
		if (DerotFreq_Hz > AdcClk_Hz)
			DerotFreq_Hz = DerotFreq_Hz - AdcClk_Hz;
		Sampled_IF = (U32) DerotFreq_Hz / 1000;
		Sampled_IF *= 32768;
		Sampled_IF /= AdcClk_kHz;
		Sampled_IF *= 256;
	}

	if (Sampled_IF > 8388607)
		Sampled_IF = 8388607;

	ChipSetFieldImage(hChip, F367qam_MIX_NCO_INC_LL, Sampled_IF);
	ChipSetFieldImage(hChip, F367qam_MIX_NCO_INC_HL, (Sampled_IF >> 8));
	ChipSetFieldImage(hChip, F367qam_MIX_NCO_INC_HH, (Sampled_IF >> 16));
	ChipSetRegisters(hChip, R367qam_MIX_NCO_LL, 3);

	return DerotFreq_Hz;
}

/*****************************************************
**FUNCTION	::	FE_367qam_GetDerotFreq
**ACTION	::	Get the STV0367QAM derotator frequency
**PARAMS IN	::  hChip		==>	handle to the chip
**				AdcClk_Hz	==>	ADC clock frequency(Hz)
**PARAMS OUT::	Derot frequency
**RETURN	::	Derotator frequency(Hz)
*****************************************************/
U32 FE_367qam_GetDerotFreq(STCHIP_Handle_t hChip, U32 AdcClk_Hz)
{
	U32 Sampled_IF;

	ChipGetRegisters(hChip, R367qam_MIX_NCO_LL, 3);
	Sampled_IF = ChipGetFieldImage(hChip, F367qam_MIX_NCO_INC_LL)
	    + (ChipGetFieldImage(hChip, F367qam_MIX_NCO_INC_HL) << 8)
	    + (ChipGetFieldImage(hChip, F367qam_MIX_NCO_INC_HH) << 16);

	Sampled_IF /= 256;
	Sampled_IF *= (AdcClk_Hz / 1000);
	Sampled_IF += 1;
	Sampled_IF /= 32768;

	return Sampled_IF;
}

/*****************************************************
**FUNCTION	::	FE_367qam_SetIirAdjacentcoefficient
**ACTION	::	Set the STV0367QAM IIR filter coefficients
**PARAMS IN	::  hChip		==>	handle to the chip
**				MasterClk_Hz	==>	Master frequency in Hz
**				SymbolRate	==>	Symbol rate in Bauds
**PARAMS OUT::	NONE
**RETURN	::	None
*****************************************************/
void FE_367qam_SetIirAdjacentcoefficient(STCHIP_Handle_t hChip,
					 U32 MasterClk_Hz, U32 SymbolRate)
{
	U16 line = 0, i;
	U32 Fn0, Fn1000, NormFreq;
	U16 rolloff;
	S32 coeff[6] = { 0, 0, 0, 0, 0, 0 };
	U32 AdpClk_kHz;
	U16 Section, SectionLine;
	S32 PolyC[48][4] = {	/* a1[0] part */
		{5, -19, -754, 7721},
		{0, -10, -779, 6946},
		{11, -23, -794, 6151},
		{-4, 1, -824, 5339},
		{-9, 1, -839, 4505},
		{-2, -9, -859, 3653},
		{0, -16, -881, 2776},
		{-27, 7, -920, 1871},
		/* a1[1] part */
		{-7, 115, -1325, 7312},
		{12, 72, -1114, 6087},
		{14, 48, -939, 5047},
		{-6, 68, -817, 4163},
		{0, 51, -692, 3403},
		{-12, 68, -595, 2758},
		{-4, 58, -491, 2216},
		{0, 53, -382, 1776},
		/* B1 part */
		{1, 148, 191, -4035},
		{-16, 150, 486, -3693},
		{-17, 134, 746, -3065},
		{-40, 142, 950, -2193},
		{-19, 75, 1124, -1130},
		{-14, 35, 1219, 60},
		{-5, -14, 1251, 1310},
		{-32, -10, 1194, 2551},
		/* a2[0] part */
		{12, -147, -322, 8045},
		{5, -127, -587, 7583},
		{25, -129, -820, 6869},
		{-8, -67, -1038, 5935},
		{7, -69, -1190, 4813},
		{3, -44, -1310, 3551},
		{4, -22, -1387, 2189},
		{-5, 11, -1421, 773},
		/* a2[1] part */
		{1, 4, -282, 8011},
		{5, -3, -266, 7731},
		{12, -10, -252, 7465},
		{-3, 12, -244, 7213},
		{-1, 10, -227, 6976},
		{11, -6, -203, 6757},
		{1, 8, -186, 6556},
		{11, -1, -161, 6378},
		/* B2 part */
		{-54, 408, 573, -3908},
		{-65, 191, 1215, -2973},
		{-49, 5, 1399, -1621},
		{-7, -108, 1284, -253},
		{-6, -103, 1031, 928},
		{-7, -93, 798, 1856},
		{4, -89, 601, 2560},
		{7, -75, 440, 3080}
	};

	rolloff = ChipGetField(hChip, F367qam_NYQ_COEFF_SEL);
	switch (rolloff) {
	case 0:
		rolloff = 112;
		break;
	case 1:
		rolloff = 113;
		break;
	case 2:
		rolloff = 115;
		break;
	case 3:
		rolloff = 118;
		break;
	default:
		rolloff = 115;
		break;
	}
	Fn0 = 36800;		/* 1000000*1.15 * 0.8/25 */
	Fn1000 = 496800;	/* 1000000*1.15*10.8/25 */

	AdpClk_kHz = (MasterClk_Hz >> 1) / 1000;
	if (AdpClk_kHz != 0) {
		if (SymbolRate >= 4000000)
			NormFreq = SymbolRate * rolloff;
		else
			NormFreq = (SymbolRate + 250000) * rolloff;
		NormFreq = NormFreq / AdpClk_kHz;
		NormFreq *= 10;	/* 1000000*rolloff*Fs/Fadp */
		line = (NormFreq - Fn0) / 460;
		/* 1000*(NormFreq - Fn0)/(Fn1000 - Fn0) */
	}

	if (line > 999)
		line = 999;

	Section = (U16) (line / 128);	/* Section goes from 0 to 7 */
	/* SectionLine goes from 1 to 128 */
	SectionLine = line + 1 - (Section * 128);
	for (i = 0; i < 6; i++)
		coeff[i] = ((PolyC[Section + (8 * i)][3]) +
			    ((SectionLine * PolyC[Section + (8 * i)][2] *
			      8192) +
			     (((XtoPowerY(SectionLine, 2) *
				PolyC[Section + (8 * i)][1] * 128) +
			       ((XtoPowerY(SectionLine, 3) *
				 PolyC[Section +
				       (8 * i)][0]))) / 2)) / 1048576) / 8;

	if (coeff[2] < 0)
		coeff[2] += 1024;
	if (coeff[5] < 0)
		coeff[5] += 1024;

	/* Data is written in the Image and actual
	   I2c write will be done later */
	ChipSetFieldImage(hChip, F367qam_ADJIIR_COEFF10_L, coeff[0]);
	ChipSetFieldImage(hChip, F367qam_ADJIIR_COEFF10_H, (coeff[0]) >> 8);
	ChipSetFieldImage(hChip, F367qam_ADJIIR_COEFF11_L, coeff[1]);
	ChipSetFieldImage(hChip, F367qam_ADJIIR_COEFF11_H, (coeff[1]) >> 6);
	ChipSetFieldImage(hChip, F367qam_ADJIIR_COEFF12_L, coeff[2]);
	ChipSetFieldImage(hChip, F367qam_ADJIIR_COEFF12_H, (coeff[2]) >> 4);
	ChipSetFieldImage(hChip, F367qam_ADJIIR_COEFF20_L, coeff[3]);
	ChipSetFieldImage(hChip, F367qam_ADJIIR_COEFF20_H, (coeff[3]) >> 2);
	ChipSetFieldImage(hChip, F367qam_ADJIIR_COEFF21_L, coeff[4]);
	ChipSetFieldImage(hChip, F367qam_ADJIIR_COEFF21_H, (coeff[4]) >> 8);
	ChipSetFieldImage(hChip, F367qam_ADJIIR_COEFF22_L, coeff[5]);
	ChipSetFieldImage(hChip, F367qam_ADJIIR_COEFF22_H, (coeff[5]) >> 6);
	/* Values are now written into the 367QAM registers */
	ChipSetRegisters(hChip, R367qam_IQDEM_ADJ_COEFF0, 10);

	return;
}

/*****************************************************
**FUNCTION	::	FE_367qam_SetAllPasscoefficient
**ACTION	::	Set the STV0367QAM Allpass filter coefficients
**PARAMS IN	::  hChip		==>	handle to the chip
**				MasterClk_Hz	==>	Master frequency in Hz
**				SymbolRate	==>	Symbol rate in Bauds
**PARAMS OUT::	NONE
**RETURN	::	None
*****************************************************/
void FE_367qam_SetAllPasscoefficient(STCHIP_Handle_t hChip, U32 MasterClk_Hz,
				     U32 SymbolRate)
{
	U32 line = 0;
	U32 A, B, NormFreq;
	U16 rolloff, i;
	S32 c[4] = { 0, 0, 0, 0 };
	U32 AdpClk_kHz, SymbolRate_kHz;

	/*for test */
	/*        S32 filehandle;
	   char str[500];
	 */

	rolloff = ChipGetField(hChip, F367qam_NYQ_COEFF_SEL);
	switch (rolloff) {
	case 0:
		rolloff = 112;
		break;
	case 1:
		rolloff = 113;
		break;
	case 2:
		rolloff = 115;
		break;
	case 3:
		rolloff = 118;
		break;
	default:
		rolloff = 115;
		break;
	}
	/*for test */
	rolloff = 115;

	A = 2500;
	B = 80;			/*B = A*Fn0 = 800 */
	AdpClk_kHz = (MasterClk_Hz >> 1) / 1000;
	SymbolRate_kHz = SymbolRate / 1000;
	if (AdpClk_kHz != 0) {
		NormFreq = rolloff * SymbolRate_kHz;
		/* NormFreq*A = (rolloff*Fs/F_adp) * A  */
		NormFreq = NormFreq * A / AdpClk_kHz;
		/* line = NormFreq*A - B */
		line = (NormFreq - B * 115) / 115;
	}
	if (line >= 1000)
		line = 999;
	for (i = 0; i <= 3; i++)
		c[i] = AllPass[line][i];

	/* Data is written in the Image and actual
	   I2c write will be done later */
	ChipSetFieldImage(hChip, F367qam_ALLPASSFILT_COEFF1_LO, c[0]);
	ChipSetFieldImage(hChip, F367qam_ALLPASSFILT_COEFF1_ME, (c[0]) >> 8);
	ChipSetFieldImage(hChip, F367qam_ALLPASSFILT_COEFF1_HI, (c[0]) >> 16);
	ChipSetFieldImage(hChip, F367qam_ALLPASSFILT_COEFF2_LO, c[1]);
	ChipSetFieldImage(hChip, F367qam_ALLPASSFILT_COEFF2_MEL, (c[1]) >> 2);
	ChipSetFieldImage(hChip, F367qam_ALLPASSFILT_COEFF2_MEH, (c[1]) >> 10);
	ChipSetFieldImage(hChip, F367qam_ALLPASSFILT_COEFF2_HI, (c[1]) >> 18);
	ChipSetFieldImage(hChip, F367qam_ALLPASSFILT_COEFF3_LO, c[2]);
	ChipSetFieldImage(hChip, F367qam_ALLPASSFILT_COEFF3_MEL, (c[2]) >> 4);
	ChipSetFieldImage(hChip, F367qam_ALLPASSFILT_COEFF3_MEH, (c[2]) >> 12);
	ChipSetFieldImage(hChip, F367qam_ALLPASSFILT_COEFF3_HI, (c[2]) >> 20);
	ChipSetFieldImage(hChip, F367qam_ALLPASSFILT_COEFF4_LO, c[3]);
	ChipSetFieldImage(hChip, F367qam_ALLPASSFILT_COEFF4_ME, (c[3]) >> 6);
	ChipSetFieldImage(hChip, F367qam_ALLPASSFILT_COEFF4_HI, (c[3]) >> 14);

	ChipSetRegisters(hChip, R367qam_ALLPASSFILT1, 11);

	/*for test */
/*		filehandle = OpenFile("allpassfilter.txt", VAL_READ_WRITE,
						VAL_TRUNCATE, VAL_ASCII);
		Fmt(str, "%s<%s%d%s", "Fs=", SymbolRate_kHz, "kHz");
		FmtFile(filehandle, "%s<%s\n", str);
		Fmt(str, "%s<%s%d%s", "Adp=", AdpClk_kHz, "kHz");
		FmtFile(filehandle, "%s<%s\n", str);
		Fmt(str, "%s<%s%d", "Rolloff=", rolloff);
		FmtFile(filehandle, "%s<%s\n", str);
		Fmt(str, "%s<%s%d", "line number=", line);
		FmtFile(filehandle, "%s<%s\n", str);
		for (i = 0 ; i <= 3 ; i++){
			Fmt(str, "%s<%s%d%s%d", "c[", i, "]=", c[i]);
			FmtFile(filehandle, "%s<%s\t", str);
		}
		CloseFile(filehandle);
*/
	return;
}

/*****************************************************
**FUNCTION	::	FE_367qam_SetSymbolRate
**ACTION	::	Set symbol frequency
**PARAMS IN	::	hChip		->	handle to the chip
**				AdcClk_Hz	->	ADC frequency(Hz)
**				MasterClk_Hz	->	Master frequency(Hz)
**				SymbolRate	->	symbol rate(bauds)
**				QAMSize		->	QAM size
**PARAMS OUT::	NONE
**RETURN	::	Symbol frequency
*****************************************************/
U32 FE_367qam_SetSymbolRate(STCHIP_Handle_t hChip, U32 AdcClk_Hz,
			    U32 MasterClk_Hz, U32 SymbolRate,
			    FE_CAB_Modulation_t QAMSize)
{
	U32 QamSizeCorr = 0;
	U32 u32_tmp = 0, u32_tmp1 = 0;
	U32 AdpClk_kHz;

	/* Set Correction factor of SRC gain */
	switch (QAMSize) {
	case FE_CAB_MOD_QAM4:
		QamSizeCorr = 1110;
		break;
	case FE_CAB_MOD_QAM16:
		QamSizeCorr = 1032;
		break;
	case FE_CAB_MOD_QAM32:
		QamSizeCorr = 954;
		break;
	case FE_CAB_MOD_QAM64:
		QamSizeCorr = 983;
		break;
	case FE_CAB_MOD_QAM128:
		QamSizeCorr = 957;
		break;
	case FE_CAB_MOD_QAM256:
		QamSizeCorr = 948;
		break;
	case FE_CAB_MOD_QAM512:
		QamSizeCorr = 0;
		break;
	case FE_CAB_MOD_QAM1024:
		QamSizeCorr = 944;
		break;
	default:
		break;
	}

	/* Transfer ratio calculation */
	if (AdcClk_Hz != 0) {
		u32_tmp = 256 * SymbolRate;
		u32_tmp = u32_tmp / AdcClk_Hz;
	}
	ChipSetOneRegister(hChip, R367qam_EQU_CRL_TFR, (U8) u32_tmp);

	/* Symbol rate and SRC gain calculation */
	/* TRL works at half the system clock */
	AdpClk_kHz = (MasterClk_Hz >> 1) / 1000;
	if (AdpClk_kHz != 0) {
		u32_tmp = SymbolRate;
		u32_tmp1 = SymbolRate;

		if (u32_tmp < 2097152) {	/* 2097152 = 2^21 */
			/* Symbol rate calculation */
			u32_tmp *= 2048;	/* 2048 = 2^11 */
			u32_tmp = u32_tmp / AdpClk_kHz;
			u32_tmp = u32_tmp * 16384;	/* 16384 = 2^14 */
			u32_tmp /= 125;	/* 125 = 1000/2^3 */
			u32_tmp = u32_tmp * 8;	/* 8 = 2^3 */

			/* SRC Gain Calculation */
			u32_tmp1 *= 2048;	/* *2*2^10 */
			u32_tmp1 /= 439;	/* *2/878 */
			u32_tmp1 *= 256;	/* *2^8 */
			/*/(AdpClk in kHz) */
			u32_tmp1 = u32_tmp1 / AdpClk_kHz;
			u32_tmp1 *= QamSizeCorr * 9;	/* *1000*corr factor */
			u32_tmp1 = u32_tmp1 / 10000000;

		} else if (u32_tmp < 4194304) {	/* 4194304 = 2**22 */
			/* Symbol rate calculation */
			u32_tmp *= 1024;	/* 1024 = 2**10 */
			u32_tmp = u32_tmp / AdpClk_kHz;
			u32_tmp = u32_tmp * 16384;	/* 16384 = 2**14 */
			u32_tmp /= 125;	/* 125 = 1000/2**3 */
			u32_tmp = u32_tmp * 16;	/* 16 = 2**4 */

			/* SRC Gain Calculation */
			u32_tmp1 *= 1024;	/* *2*2^9 */
			u32_tmp1 /= 439;	/* *2/878 */
			u32_tmp1 *= 256;	/* *2^8 */
			/*/(AdpClk in kHz) */
			u32_tmp1 = u32_tmp1 / AdpClk_kHz;
			u32_tmp1 *= QamSizeCorr * 9;	/* *1000*corr factor */
			u32_tmp1 = u32_tmp1 / 5000000;
		} else if (u32_tmp < 8388607) {	/* 8388607 = 2**23 */
			/* Symbol rate calculation */
			u32_tmp *= 512;	/* 512 = 2**9 */
			u32_tmp = u32_tmp / AdpClk_kHz;
			u32_tmp = u32_tmp * 16384;	/* 16384 = 2**14 */
			u32_tmp /= 125;	/* 125 = 1000/2**3 */
			u32_tmp = u32_tmp * 32;	/* 32 = 2**5 */

			/* SRC Gain Calculation */
			u32_tmp1 *= 512;	/* *2*2^8 */
			u32_tmp1 /= 439;	/* *2/878 */
			u32_tmp1 *= 256;	/* *2^8 */
			/*/(AdpClk in kHz) */
			u32_tmp1 = u32_tmp1 / AdpClk_kHz;
			u32_tmp1 *= QamSizeCorr * 9;	/* *1000*corr factor */
			u32_tmp1 = u32_tmp1 / 2500000;
		} else {
			/* Symbol rate calculation */
			u32_tmp *= 256;	/* 256 = 2**8 */
			u32_tmp = u32_tmp / AdpClk_kHz;
			u32_tmp = u32_tmp * 16384;	/* 16384 = 2**13 */
			u32_tmp /= 125;	/* 125 = 1000/2**3 */
			u32_tmp = u32_tmp * 64;	/* 64 = 2**6 */

			/* SRC Gain Calculation */
			u32_tmp1 *= 256;	/* 2*2^7 */
			u32_tmp1 /= 439;	/* *2/878 */
			u32_tmp1 *= 256;	/* *2^8 */
			/*/(AdpClk in kHz) */
			u32_tmp1 = u32_tmp1 / AdpClk_kHz;
			u32_tmp1 *= QamSizeCorr * 9;	/* *1000*corr factor */
			u32_tmp1 = u32_tmp1 / 1250000;
		}
	}

	/* Filters' coefficients are calculated and written
	   into registers only if the filters are enabled */
	if (ChipGetField(hChip, F367qam_ADJ_EN)) {
		FE_367qam_SetIirAdjacentcoefficient(hChip, MasterClk_Hz,
						    SymbolRate);
	}
	/* AllPass filter is never used on this IC */
	ChipSetField(hChip, F367qam_ALLPASSFILT_EN, 0);

	ChipSetFieldImage(hChip, F367qam_SRC_NCO_INC_LL, u32_tmp);
	ChipSetFieldImage(hChip, F367qam_SRC_NCO_INC_LH, (u32_tmp >> 8));
	ChipSetFieldImage(hChip, F367qam_SRC_NCO_INC_HL, (u32_tmp >> 16));
	ChipSetFieldImage(hChip, F367qam_SRC_NCO_INC_HH, (u32_tmp >> 24));

	ChipSetFieldImage(hChip, F367qam_GAIN_SRC_LO, u32_tmp1 & 0x00ff);
	ChipSetFieldImage(hChip, F367qam_GAIN_SRC_HI, (u32_tmp1 >> 8) & 0x00ff);

	ChipSetRegisters(hChip, R367qam_SRC_NCO_LL, 6);
	return SymbolRate;
}

/*****************************************************
**FUNCTION	::	FE_367qam_GetSymbolRate
**ACTION	::	Get the current symbol rate
**PARAMS IN	::	hChip		->	handle to the chip
**				MasterClk_Hz->	Master frequency(Hz)
**PARAMS OUT::	NONE
**RETURN	::	Symbol rate
*****************************************************/
U32 FE_367qam_GetSymbolRate(STCHIP_Handle_t hChip, U32 MasterClk_Hz)
{
	U32 regsym;
	U32 AdpClk_kHz;

	ChipGetRegisters(hChip, R367qam_SRC_NCO_LL, 4);
	regsym = ChipGetFieldImage(hChip, F367qam_SRC_NCO_INC_LL)
	    + (ChipGetFieldImage(hChip, F367qam_SRC_NCO_INC_LH) << 8)
	    + (ChipGetFieldImage(hChip, F367qam_SRC_NCO_INC_HL) << 16)
	    + (ChipGetFieldImage(hChip, F367qam_SRC_NCO_INC_HH) << 24);

	/* TRL works at half the system clock */
	AdpClk_kHz = (MasterClk_Hz >> 1) / 1000;

	if (regsym < 134217728) {	/* 134217728L = 2**27 */
		regsym = regsym * 32;	/* 32 = 2**5 */
		regsym = regsym / 32768;	/* 32768L = 2**15 */
		regsym = AdpClk_kHz * regsym;	/* AdpClk in kHz */
		regsym = regsym / 128;	/* 128 = 2**7 */
		regsym *= 125;	/* 125 = 1000/2**3 */
		regsym /= 2048;	/* 2048 = 2**11 */
	} else if (regsym < 268435456) {	/* 268435456L = 2**28 */
		regsym = regsym * 16;	/* 16 = 2**4 */
		regsym = regsym / 32768;	/* 32768L = 2**15 */
		regsym = AdpClk_kHz * regsym;	/* AdpClk in kHz */
		regsym = regsym / 128;	/* 128 = 2**7 */
		regsym *= 125;	/* 125 = 1000/2**3 */
		regsym /= 1024;	/* 256 = 2**10 */
	} else if (regsym < 536870912) {	/* 536870912L = 2**29 */
		regsym = regsym * 8;	/* 8 = 2**3 */
		regsym = regsym / 32768;	/* 32768L = 2**15 */
		regsym = AdpClk_kHz * regsym;	/* AdpClk in kHz */
		regsym = regsym / 128;	/* 128 = 2**7 */
		regsym *= 125;	/* 125 = 1000/2**3 */
		regsym /= 512;	/* 128 = 2**9 */
	} else {
		regsym = regsym * 4;	/* 4 = 2**2 */
		regsym = regsym / 32768;	/* 32768L = 2**15 */
		regsym = AdpClk_kHz * regsym;	/* AdpClk in kHz */
		regsym = regsym / 128;	/* 128 = 2**7 */
		regsym *= 125;	/* 125 = 1000/2**3 */
		regsym /= 256;	/* 64 = 2**8 */
	}
	return regsym;
}

/*****************************************************
**FUNCTION	::	FE_367qam_SetQamSize
**ACTION	::	Set the QAM size and some related parameters
**PARAMS IN	::	hChip->	handle to the chip
**hTuner->handle to the tuner
**QAMSize->	QAM size)
**PARAMS OUT::	NONE
**RETURN	::	QAM size
*****************************************************/
FE_CAB_Modulation_t FE_367qam_SetQamSize(STCHIP_Handle_t hChip,
					 STCHIP_Handle_t hTuner,
					 U32 SearchFreq_kHz, U32 SymbolRate,
					 FE_CAB_Modulation_t QAMSize)
{
	/* Set QAM size */
	ChipSetField(hChip, F367qam_QAM_MODE, QAMSize);

	/* Set Registers settings specific to the QAM size */
	switch (QAMSize) {
	case FE_CAB_MOD_QAM16:
		switch (FE_TunerGetModelName(hTuner)) {
		case TUNER_DTT7546:
			/* Set analog AGC reference */
			ChipSetOneRegister(hChip, R367qam_AGC_PWR_REF_L, 0x64);
			break;
		case TUNER_DNOS40AS:
			/* Set analog AGC reference */
			ChipSetOneRegister(hChip, R367qam_AGC_PWR_REF_L, 0x64);
			break;
		case TUNER_STV4100:
			/* Set analog AGC reference */
			ChipSetOneRegister(hChip, R367qam_AGC_PWR_REF_L, 0x64);
			break;
		case TUNER_DCT70700:
			/* Set analog AGC reference */
			ChipSetOneRegister(hChip, R367qam_AGC_PWR_REF_L, 0x64);
			break;
		case TUNER_MXL203RF:
			ChipSetOneRegister(hChip, R367qam_AGC_PWR_REF_L, 0x64);
			break;
		case TUNER_CD1616LF:
			ChipSetOneRegister(hChip, R367qam_AGC_PWR_REF_L, 0x64);
			break;
		case TUNER_TDCCG:
			ChipSetOneRegister(hChip, R367qam_AGC_PWR_REF_L, 0x64);
			break;
		case TUNER_FQD1116:
			ChipSetOneRegister(hChip, R367qam_AGC_PWR_REF_L, 0x64);
			break;
		case TUNER_CD1100:
			ChipSetOneRegister(hChip, R367qam_AGC_PWR_REF_L, 0x64);
			/* Improving ACI performances */
			ChipSetOneRegister(hChip, R367qam_IQDEM_ADJ_EN, 0x05);
			break;
		case TUNER_MT2066:
			ChipSetOneRegister(hChip, R367qam_AGC_PWR_REF_L, 0x64);
			break;
		case TUNER_TDA18250:
			ChipSetOneRegister(hChip, R367qam_AGC_PWR_REF_L, 0x64);
			break;
		case TUNER_TDA18212:
			ChipSetOneRegister(hChip, R367qam_AGC_PWR_REF_L, 0x64);
			ChipSetOneRegister(hChip, R367qam_AGC_CTL, 0x73);
			break;
		case TUNER_TDA18219:
		case TUNER_TDA18250A:
			ChipSetOneRegister(hChip, R367qam_AGC_PWR_REF_L, 0x64);
			ChipSetOneRegister(hChip, R367qam_AGC_CTL, 0x73);
			break;
		case TUNER_MXL603:
			ChipSetOneRegister(hChip, R367qam_AGC_PWR_REF_L, 0x64);
			ChipSetOneRegister(hChip, R367qam_AGC_CTL, 0x77);
			break;
		default:
			/* Analog AGC reference will be set through the
			   configuration file for non optimized tuners */
			break;
		}
		ChipSetOneRegister(hChip, R367qam_FSM_SNR2_HTH, 0x00);
		/* Set digital AGC reference */
		ChipSetOneRegister(hChip, R367qam_IQDEM_ADJ_AGC_REF, 0x00);
		ChipSetOneRegister(hChip, R367qam_FSM_STATE, 0x90);
		ChipSetOneRegister(hChip, R367qam_EQU_CTR_LPF_GAIN, 0xc1);
		ChipSetOneRegister(hChip, R367qam_EQU_CRL_LPF_GAIN, 0xa7);
		ChipSetOneRegister(hChip, R367qam_EQU_CRL_LD_SEN, 0x95);
		ChipSetOneRegister(hChip, R367qam_EQU_CRL_LIMITER, 0x40);
		ChipSetOneRegister(hChip, R367qam_EQU_PNT_GAIN, 0x8a);
		break;
	case FE_CAB_MOD_QAM32:
		switch (FE_TunerGetModelName(hTuner)) {
		case TUNER_DTT7546:
			ChipSetOneRegister(hChip, R367qam_AGC_PWR_REF_L, 0x6e);
			break;
		case TUNER_DNOS40AS:
			ChipSetOneRegister(hChip, R367qam_AGC_PWR_REF_L, 0x6e);
			break;
		case TUNER_STV4100:
			ChipSetOneRegister(hChip, R367qam_AGC_PWR_REF_L, 0x6e);
			break;
		case TUNER_DCT70700:
			ChipSetOneRegister(hChip, R367qam_AGC_PWR_REF_L, 0x6e);
			break;
		case TUNER_MXL203RF:
			ChipSetOneRegister(hChip, R367qam_AGC_PWR_REF_L, 0x6e);
			break;
		case TUNER_CD1616LF:
			ChipSetOneRegister(hChip, R367qam_AGC_PWR_REF_L, 0x6e);
			break;
		case TUNER_TDCCG:
			ChipSetOneRegister(hChip, R367qam_AGC_PWR_REF_L, 0x6e);
			break;
		case TUNER_FQD1116:
			ChipSetOneRegister(hChip, R367qam_AGC_PWR_REF_L, 0x6e);
			break;
		case TUNER_CD1100:
			ChipSetOneRegister(hChip, R367qam_AGC_PWR_REF_L, 0x6e);
			ChipSetOneRegister(hChip, R367qam_IQDEM_ADJ_EN, 0x05);
			break;
		case TUNER_MT2066:
			ChipSetOneRegister(hChip, R367qam_AGC_PWR_REF_L, 0x6e);
			break;
		case TUNER_TDA18250:
			ChipSetOneRegister(hChip, R367qam_AGC_PWR_REF_L, 0x6e);
			break;
		case TUNER_TDA18212:
			ChipSetOneRegister(hChip, R367qam_AGC_PWR_REF_L, 0x6e);
			ChipSetOneRegister(hChip, R367qam_AGC_CTL, 0x73);
			break;
		case TUNER_TDA18219:
		case TUNER_TDA18250A:
			ChipSetOneRegister(hChip, R367qam_AGC_PWR_REF_L, 0x6e);
			ChipSetOneRegister(hChip, R367qam_AGC_CTL, 0x73);
			break;
		case TUNER_MXL603:
			ChipSetOneRegister(hChip, R367qam_AGC_PWR_REF_L, 0x6e);
			ChipSetOneRegister(hChip, R367qam_AGC_CTL, 0x77);
			break;
		default:
			/* Analog AGC reference will be set through
			   the configuration file for non optimized tuners */
			break;
		}
		ChipSetOneRegister(hChip, R367qam_FSM_SNR2_HTH, 0x00);
		/* Set digital AGC reference */
		ChipSetOneRegister(hChip, R367qam_IQDEM_ADJ_AGC_REF, 0x00);
		ChipSetOneRegister(hChip, R367qam_FSM_STATE, 0xb0);
		ChipSetOneRegister(hChip, R367qam_EQU_CTR_LPF_GAIN, 0xc1);
		ChipSetOneRegister(hChip, R367qam_EQU_CRL_LPF_GAIN, 0xb7);
		ChipSetOneRegister(hChip, R367qam_EQU_CRL_LD_SEN, 0x9d);
		ChipSetOneRegister(hChip, R367qam_EQU_CRL_LIMITER, 0x7f);
		ChipSetOneRegister(hChip, R367qam_EQU_PNT_GAIN, 0xa7);
		break;
	case FE_CAB_MOD_QAM64:
		switch (FE_TunerGetModelName(hTuner)) {
		case TUNER_DTT7546:
			ChipSetOneRegister(hChip, R367qam_AGC_PWR_REF_L, 0x5a);
			/* Set analog AGC reference */
			/* AGC thresholds and accumulation as defined in
			   the init table are good */
			break;
		case TUNER_DNOS40AS:
			ChipSetOneRegister(hChip, R367qam_AGC_PWR_REF_L, 0x5a);
			/* Set analog AGC reference */
			/* AGC thresholds and accumulation as defined in
			   the init table are good */
			break;
		case TUNER_STV4100:
			ChipSetOneRegister(hChip, R367qam_AGC_PWR_REF_L, 0x5a);
			/* Set analog AGC reference */
			/* AGC thresholds and accumulation as defined in
			   the init table are good */
			break;
		case TUNER_DCT70700:
			ChipSetOneRegister(hChip, R367qam_AGC_PWR_REF_L, 0x5a);
			/* Set analog AGC reference */
			/* AGC thresholds and accumulation as defined in
			   the init table are good */
			break;
		case TUNER_MXL203RF:
			ChipSetOneRegister(hChip, R367qam_AGC_PWR_REF_L, 0x5a);
			/* Set analog AGC reference */
			/* AGC thresholds and accumulation as defined in
			   the init table are good */
			break;
		case TUNER_TDCCG:
			ChipSetOneRegister(hChip, R367qam_AGC_PWR_REF_L, 0x5a);
			/* Set analog AGC reference */
			/* AGC thresholds and accumulation as defined in
			   the init table are good */
			break;
		case TUNER_CD1616LF:
			ChipSetOneRegister(hChip, R367qam_AGC_PWR_REF_L, 0x5a);
			/* Set analog AGC reference */
			/* AGC thresholds and accumulation as defined in
			   the init table have to be modified */
			ChipSetOneRegister(hChip, R367qam_AGC_CTL, 0x70);
			ChipSetOneRegister(hChip, R367qam_AGC_IF_LTH_L, 0x10);
			ChipSetOneRegister(hChip, R367qam_AGC_IF_LTH_H, 0x0c);
			ChipSetOneRegister(hChip, R367qam_AGC_IF_HTH_L, 0x8c);
			ChipSetOneRegister(hChip, R367qam_AGC_IF_HTH_H, 0x00);
			if (SearchFreq_kHz <= 459000) {
				ChipSetOneRegister(hChip, R367qam_AGC_RF_TH_L,
						   0x99);
				ChipSetOneRegister(hChip, R367qam_AGC_RF_TH_H,
						   0x01);
			} else {
				ChipSetOneRegister(hChip, R367qam_AGC_RF_TH_L,
						   0x36);
				ChipSetOneRegister(hChip, R367qam_AGC_RF_TH_H,
						   0x00);
			}
			/* Improving ACI performances */
			ChipSetOneRegister(hChip, R367qam_IQDEM_ADJ_EN, 0x0d);
			break;
		case TUNER_FQD1116:
			ChipSetOneRegister(hChip, R367qam_AGC_PWR_REF_L, 0x5a);
			/* Set analog AGC reference */
			break;
		case TUNER_MT2066:
			ChipSetOneRegister(hChip, R367qam_AGC_PWR_REF_L, 0x5a);
			/* Set analog AGC reference */
			/* AGC thresholds and accumulation as defined in
			   the init table are good */
			break;
		case TUNER_CD1100:
			ChipSetOneRegister(hChip, R367qam_AGC_CTL, 0x70);
			ChipSetOneRegister(hChip, R367qam_AGC_PWR_REF_L, 0x5a);
			ChipSetOneRegister(hChip, R367qam_AGC_RF_TH_L, 0x36);
			ChipSetOneRegister(hChip, R367qam_AGC_RF_TH_H, 0x00);
			ChipSetOneRegister(hChip, R367qam_AGC_IF_LTH_L, 0x66);
			ChipSetOneRegister(hChip, R367qam_AGC_IF_LTH_H, 0x0e);
			ChipSetOneRegister(hChip, R367qam_AGC_IF_HTH_L, 0x99);
			ChipSetOneRegister(hChip, R367qam_AGC_IF_HTH_H, 0x01);
			break;
		case TUNER_TDA18250:
			/* Set analog AGC reference */
			/* AGC thresholds and accumulation as defined
			   in the init table have to be modified */
			ChipSetOneRegister(hChip, R367qam_AGC_PWR_REF_L, 0x5a);
			ChipSetOneRegister(hChip, R367qam_AGC_CTL, 0x70);
			ChipSetOneRegister(hChip, R367qam_AGC_IF_LTH_L, 0x10);
			ChipSetOneRegister(hChip, R367qam_AGC_IF_LTH_H, 0x0c);
			ChipSetOneRegister(hChip, R367qam_AGC_IF_HTH_L, 0x8c);
			ChipSetOneRegister(hChip, R367qam_AGC_IF_HTH_H, 0x00);
			ChipSetOneRegister(hChip, R367qam_AGC_RF_TH_L, 0x99);
			ChipSetOneRegister(hChip, R367qam_AGC_RF_TH_H, 0x01);
			/* Improving ACI performances */
			ChipSetOneRegister(hChip, R367qam_IQDEM_ADJ_EN, 0x05);
			break;
		case TUNER_TDA18212:
			ChipSetOneRegister(hChip, R367qam_AGC_PWR_REF_L, 0x5a);
			ChipSetOneRegister(hChip, R367qam_AGC_CTL, 0x73);
			break;
		case TUNER_TDA18219:
		case TUNER_TDA18250A:
			ChipSetOneRegister(hChip, R367qam_AGC_PWR_REF_L, 0x5a);
			ChipSetOneRegister(hChip, R367qam_AGC_CTL, 0x73);
			break;
		case TUNER_MXL603:
			ChipSetOneRegister(hChip, R367qam_AGC_PWR_REF_L, 0x5a);
			ChipSetOneRegister(hChip, R367qam_AGC_CTL, 0x77);
			break;

		default:
			/* Analog AGC reference will be set through the
			   configuration file for non optimized tuners */
			break;
		}
		/* Set digital AGC reference */
		ChipSetOneRegister(hChip, R367qam_IQDEM_ADJ_AGC_REF, 0x82);
		if (SymbolRate > 4500000) {
			ChipSetOneRegister(hChip, R367qam_FSM_STATE, 0xb0);
			ChipSetOneRegister(hChip, R367qam_EQU_CTR_LPF_GAIN,
					   0xc1);
			ChipSetOneRegister(hChip, R367qam_EQU_CRL_LPF_GAIN,
					   0xa5);
		} else if (SymbolRate > 2500000) {
			ChipSetOneRegister(hChip, R367qam_FSM_STATE, 0xa0);
			ChipSetOneRegister(hChip, R367qam_EQU_CTR_LPF_GAIN,
					   0xc1);
			ChipSetOneRegister(hChip, R367qam_EQU_CRL_LPF_GAIN,
					   0xa6);
		} else {
			ChipSetOneRegister(hChip, R367qam_FSM_STATE, 0xa0);
			ChipSetOneRegister(hChip, R367qam_EQU_CTR_LPF_GAIN,
					   0xd1);
			ChipSetOneRegister(hChip, R367qam_EQU_CRL_LPF_GAIN,
					   0xa7);
		}
		/* Improves the C/N lock limit */
		ChipSetOneRegister(hChip, R367qam_FSM_SNR2_HTH, 0x23);
		ChipSetOneRegister(hChip, R367qam_EQU_CRL_LD_SEN, 0x95);
		ChipSetOneRegister(hChip, R367qam_EQU_CRL_LIMITER, 0x40);
		ChipSetOneRegister(hChip, R367qam_EQU_PNT_GAIN, 0x99);
		break;
	case FE_CAB_MOD_QAM128:
		switch (FE_TunerGetModelName(hTuner)) {
		case TUNER_DTT7546:
			/* Set analog AGC reference */
			ChipSetOneRegister(hChip, R367qam_AGC_PWR_REF_L, 0x76);
			break;
		case TUNER_DNOS40AS:
			/* Set analog AGC reference */
			ChipSetOneRegister(hChip, R367qam_AGC_PWR_REF_L, 0x76);
			break;
		case TUNER_STV4100:
			/* Set analog AGC reference */
			ChipSetOneRegister(hChip, R367qam_AGC_PWR_REF_L, 0x76);
			break;
		case TUNER_DCT70700:
			/* Set analog AGC reference */
			ChipSetOneRegister(hChip, R367qam_AGC_PWR_REF_L, 0x76);
			break;
		case TUNER_MXL203RF:
			/* Set analog AGC reference */
			ChipSetOneRegister(hChip, R367qam_AGC_PWR_REF_L, 0x76);
			break;
		case TUNER_TDCCG:
			/* Set analog AGC reference */
			ChipSetOneRegister(hChip, R367qam_AGC_PWR_REF_L, 0x76);
			break;
		case TUNER_CD1616LF:
			/* Set analog AGC reference */
			ChipSetOneRegister(hChip, R367qam_AGC_PWR_REF_L, 0x76);
			break;
		case TUNER_FQD1116:
			/* Set analog AGC reference */
			ChipSetOneRegister(hChip, R367qam_AGC_PWR_REF_L, 0x76);
			break;
		case TUNER_CD1100:
			/* Set analog AGC reference */
			ChipSetOneRegister(hChip, R367qam_AGC_PWR_REF_L, 0x5a);
			/* AGC thresholds and accumulation as defined in
			   the init table have to be modified */
			ChipSetOneRegister(hChip, R367qam_AGC_CTL, 0x73);
			ChipSetOneRegister(hChip, R367qam_AGC_RF_TH_L, 0x99);
			ChipSetOneRegister(hChip, R367qam_AGC_RF_TH_H, 0x01);
			ChipSetOneRegister(hChip, R367qam_AGC_IF_LTH_L, 0x5c);
			ChipSetOneRegister(hChip, R367qam_AGC_IF_LTH_H, 0x0c);
			ChipSetOneRegister(hChip, R367qam_AGC_IF_HTH_L, 0x85);
			ChipSetOneRegister(hChip, R367qam_AGC_IF_HTH_H, 0x0e);
			ChipSetOneRegister(hChip, R367qam_IQDEM_ADJ_EN, 0x04);
			break;
		case TUNER_MT2066:
			/* Set analog AGC reference */
			ChipSetOneRegister(hChip, R367qam_AGC_PWR_REF_L, 0x76);
			break;
		case TUNER_TDA18250:
			/* Set analog AGC reference */
			ChipSetOneRegister(hChip, R367qam_AGC_PWR_REF_L, 0x76);
			break;
		case TUNER_TDA18212:
			ChipSetOneRegister(hChip, R367qam_AGC_PWR_REF_L, 0x76);
			ChipSetOneRegister(hChip, R367qam_AGC_CTL, 0x73);
			break;
		case TUNER_TDA18219:
		case TUNER_TDA18250A:
			ChipSetOneRegister(hChip, R367qam_AGC_PWR_REF_L, 0x76);
			ChipSetOneRegister(hChip, R367qam_AGC_CTL, 0x73);
			break;
		case TUNER_MXL603:
			ChipSetOneRegister(hChip, R367qam_AGC_PWR_REF_L, 0x76);
			ChipSetOneRegister(hChip, R367qam_AGC_CTL, 0x77);
			break;
		default:
			/* Analog AGC reference will be set through the
			   configuration file for non optimized tuners */
			break;
		}
		/* Set digital AGC reference */
		ChipSetOneRegister(hChip, R367qam_IQDEM_ADJ_AGC_REF, 0x00);
		ChipSetOneRegister(hChip, R367qam_FSM_STATE, 0x90);
		ChipSetOneRegister(hChip, R367qam_EQU_CTR_LPF_GAIN, 0xb1);
		if (SymbolRate > 4500000) {
			ChipSetOneRegister(hChip, R367qam_EQU_CRL_LPF_GAIN,
					   0xa7);
		} else if (SymbolRate > 2500000) {
			ChipSetOneRegister(hChip, R367qam_EQU_CRL_LPF_GAIN,
					   0xa6);
		} else {
			ChipSetOneRegister(hChip, R367qam_EQU_CRL_LPF_GAIN,
					   0x97);
		}
		/* Improves the C/N lock limit */
		ChipSetOneRegister(hChip, R367qam_FSM_SNR2_HTH, 0x23);
		ChipSetOneRegister(hChip, R367qam_EQU_CRL_LD_SEN, 0x8e);
		ChipSetOneRegister(hChip, R367qam_EQU_CRL_LIMITER, 0x7f);
		ChipSetOneRegister(hChip, R367qam_EQU_PNT_GAIN, 0xa7);
		break;
	case FE_CAB_MOD_QAM256:
		switch (FE_TunerGetModelName(hTuner)) {
		case TUNER_DTT7546:
			/* Set analog AGC reference */
			ChipSetOneRegister(hChip, R367qam_AGC_PWR_REF_L, 0x5a);
			/* AGC thresholds and accumulation as defined in the
			   init table are good */
			break;
		case TUNER_DNOS40AS:
			/* Set analog AGC reference */
			ChipSetOneRegister(hChip, R367qam_AGC_PWR_REF_L, 0x5a);
			/* AGC thresholds and accumulation as defined in the
			   init table are good */
			break;
		case TUNER_STV4100:
			/* Set analog AGC reference */
			ChipSetOneRegister(hChip, R367qam_AGC_PWR_REF_L, 0x5a);
			/* AGC thresholds and accumulation as defined in the
			   init table are good */
			break;
		case TUNER_DCT70700:
			/* Set analog AGC reference */
			ChipSetOneRegister(hChip, R367qam_AGC_PWR_REF_L, 0x5a);
			/* AGC thresholds and accumulation as defined in the
			   init table are good */
			break;
		case TUNER_MXL203RF:
			/* Set analog AGC reference */
			ChipSetOneRegister(hChip, R367qam_AGC_PWR_REF_L, 0x5a);
			/* AGC thresholds and accumulation as defined in the
			   init table are good */
			break;
		case TUNER_TDCCG:
			/* Set analog AGC reference */
			ChipSetOneRegister(hChip, R367qam_AGC_PWR_REF_L, 0x5a);
			/* AGC thresholds and accumulation as defined in the
			   init table are good */
			break;
		case TUNER_CD1616LF:
			/* Set analog AGC reference */
			ChipSetOneRegister(hChip, R367qam_AGC_PWR_REF_L, 0x5a);
			/* AGC thresholds and accumulation as defined in the
			   init table have to be modified */
			ChipSetOneRegister(hChip, R367qam_AGC_CTL, 0x73);
			ChipSetOneRegister(hChip, R367qam_AGC_RF_TH_L, 0x99);
			ChipSetOneRegister(hChip, R367qam_AGC_RF_TH_H, 0x01);
			ChipSetOneRegister(hChip, R367qam_AGC_IF_LTH_L, 0x5c);
			ChipSetOneRegister(hChip, R367qam_AGC_IF_LTH_H, 0x0c);
			ChipSetOneRegister(hChip, R367qam_AGC_IF_HTH_L, 0x85);
			ChipSetOneRegister(hChip, R367qam_AGC_IF_HTH_H, 0x0e);
			/* Improving ACI performances */
			ChipSetOneRegister(hChip, R367qam_IQDEM_ADJ_EN, 0x04);
			break;
		case TUNER_FQD1116:
			/* Set analog AGC reference */
			ChipSetOneRegister(hChip, R367qam_AGC_PWR_REF_L, 0x5a);
			break;
		case TUNER_MT2066:
			/* Set analog AGC reference */
			ChipSetOneRegister(hChip, R367qam_AGC_PWR_REF_L, 0x5a);
			/* AGC thresholds and accumulation as defined in the
			   init table are good */
			break;
		case TUNER_CD1100:
			ChipSetOneRegister(hChip, R367qam_AGC_CTL, 0x73);
			/* Set analog AGC reference */
			ChipSetOneRegister(hChip, R367qam_AGC_PWR_REF_L, 0x5a);
			ChipSetOneRegister(hChip, R367qam_AGC_RF_TH_L, 0x99);
			ChipSetOneRegister(hChip, R367qam_AGC_RF_TH_H, 0x01);
			if (SearchFreq_kHz <= 162000) {
				ChipSetOneRegister(hChip, R367qam_AGC_IF_LTH_L,
						   0x14);
				ChipSetOneRegister(hChip, R367qam_AGC_IF_LTH_H,
						   0x0f);
				ChipSetOneRegister(hChip, R367qam_AGC_IF_HTH_L,
						   0x99);
				ChipSetOneRegister(hChip, R367qam_AGC_IF_HTH_H,
						   0x01);
			} else if (SearchFreq_kHz <= 448000) {
				ChipSetOneRegister(hChip, R367qam_AGC_IF_LTH_L,
						   0x55);
				ChipSetOneRegister(hChip, R367qam_AGC_IF_LTH_H,
						   0x0d);
				ChipSetOneRegister(hChip, R367qam_AGC_IF_HTH_L,
						   0x7a);
				ChipSetOneRegister(hChip, R367qam_AGC_IF_HTH_H,
						   0x00);
			} else {
				ChipSetOneRegister(hChip, R367qam_AGC_IF_LTH_L,
						   0x85);
				ChipSetOneRegister(hChip, R367qam_AGC_IF_LTH_H,
						   0x0d);
				ChipSetOneRegister(hChip, R367qam_AGC_IF_HTH_L,
						   0x99);
				ChipSetOneRegister(hChip, R367qam_AGC_IF_HTH_H,
						   0x01);
			}
			break;
		case TUNER_TDA18250:
			/* Set analog AGC reference */
			ChipSetOneRegister(hChip, R367qam_AGC_PWR_REF_L, 0x5a);
			/* AGC thresholds and accumulation as defined in the
			   init table have to be modified */
			ChipSetOneRegister(hChip, R367qam_AGC_CTL, 0x73);
			ChipSetOneRegister(hChip, R367qam_AGC_RF_TH_L, 0x99);
			ChipSetOneRegister(hChip, R367qam_AGC_RF_TH_H, 0x01);
			ChipSetOneRegister(hChip, R367qam_AGC_IF_LTH_L, 0x5c);
			ChipSetOneRegister(hChip, R367qam_AGC_IF_LTH_H, 0x0c);
			ChipSetOneRegister(hChip, R367qam_AGC_IF_HTH_L, 0x85);
			ChipSetOneRegister(hChip, R367qam_AGC_IF_HTH_H, 0x0e);
			/* Improving ACI performances */
			ChipSetOneRegister(hChip, R367qam_IQDEM_ADJ_EN, 0x05);
			break;
		case TUNER_TDA18212:
			ChipSetOneRegister(hChip, R367qam_AGC_PWR_REF_L, 0x5a);
			ChipSetOneRegister(hChip, R367qam_AGC_CTL, 0x73);
			break;
		case TUNER_TDA18219:
		case TUNER_TDA18250A:
			ChipSetOneRegister(hChip, R367qam_AGC_PWR_REF_L, 0x5a);
			ChipSetOneRegister(hChip, R367qam_AGC_CTL, 0x73);
			break;
		case TUNER_MXL603:
			ChipSetOneRegister(hChip, R367qam_AGC_PWR_REF_L, 0x5a);
			ChipSetOneRegister(hChip, R367qam_AGC_CTL, 0x77);
			break;
		default:
			/* Analog AGC reference will be set through the
			   configuration file for non optimized tuners */
			break;
		}
		/* Set digital AGC reference */
		ChipSetOneRegister(hChip, R367qam_IQDEM_ADJ_AGC_REF, 0x94);
		ChipSetOneRegister(hChip, R367qam_FSM_STATE, 0xa0);
		if (SymbolRate > 4500000) {
			ChipSetOneRegister(hChip, R367qam_EQU_CTR_LPF_GAIN,
					   0xc1);
		} else if (SymbolRate > 2500000) {
			ChipSetOneRegister(hChip, R367qam_EQU_CTR_LPF_GAIN,
					   0xc1);
		} else {
			ChipSetOneRegister(hChip, R367qam_EQU_CTR_LPF_GAIN,
					   0xd1);
		}
		/* Improves the C/N lock limit */
		ChipSetOneRegister(hChip, R367qam_FSM_SNR2_HTH, 0x23);
		ChipSetOneRegister(hChip, R367qam_EQU_CRL_LPF_GAIN, 0xa7);
		ChipSetOneRegister(hChip, R367qam_EQU_CRL_LD_SEN, 0x85);
		ChipSetOneRegister(hChip, R367qam_EQU_CRL_LIMITER, 0x40);
		ChipSetOneRegister(hChip, R367qam_EQU_PNT_GAIN, 0xa7);
		break;
	default:
		break;
	}

	return QAMSize;
}

/*****************************************************
**FUNCTION	::	FE_367qam_GetQamSize
**ACTION	::	Get the QAM size and some related parameters
**PARAMS IN	::hChip		->	handle to the chip
**PARAMS OUT::	NONE
**RETURN	::	QAM size
*****************************************************/
FE_CAB_Modulation_t FE_367qam_GetQamSize(STCHIP_Handle_t hChip)
{
	return (FE_CAB_Modulation_t) (ChipGetField(hChip, F367qam_QAM_MODE));

}

 /**/
void FE_367qam_GetWaitingTime(STCHIP_Handle_t hChip,
				  FE_CAB_Modulation_t QAMSize,
				  U32 SymbolRate_Bds,
				  FE_367qam_Monitor *Monitor_results)
{
	U32 NbBitsmSec = 0, WaitingTime = 0;

	switch (QAMSize) {
	case FE_CAB_MOD_QAM4:
		NbBitsmSec = (2 * SymbolRate_Bds) / 1000;
		break;
	case FE_CAB_MOD_QAM16:
		NbBitsmSec = (4 * SymbolRate_Bds) / 1000;
		break;
	case FE_CAB_MOD_QAM32:
		NbBitsmSec = (5 * SymbolRate_Bds) / 1000;
		break;
	case FE_CAB_MOD_QAM64:
		NbBitsmSec = (6 * SymbolRate_Bds) / 1000;
		break;
	case FE_CAB_MOD_QAM128:
		NbBitsmSec = (7 * SymbolRate_Bds) / 1000;
		break;
	case FE_CAB_MOD_QAM256:
		NbBitsmSec = (8 * SymbolRate_Bds) / 1000;
		break;
	case FE_CAB_MOD_QAM512:
		NbBitsmSec = (9 * SymbolRate_Bds) / 1000;
		break;
	case FE_CAB_MOD_QAM1024:
		NbBitsmSec = (10 * SymbolRate_Bds) / 1000;
		break;
	}
	if (NbBitsmSec == 0)
		WaitingTime = 0;
	else
		WaitingTime =
		    32768 * PowOf2(2 *
				   ChipGetField(hChip,
						F367qam_BERT_NBYTE)) /
		    NbBitsmSec;
	Monitor_results->FE_367qam_WaitingTime_ms = WaitingTime;
}

void FE_367qam_SaturationComputation(FE_367qam_Monitor *Monitor_results)
{

	U32 u32_tmp;
	/*
	   In order to get a smooth saturation value, this is filtered
	   woith a low - pass filter : sat(n) = 0.25*sat(n - 1) +
	   0.75*acc(n)
	   FE_367qam_CorrectedBitsNumber = accumulator value
	   FE_367qam_Saturation = low - pass filter memory
	 */

	u32_tmp = Monitor_results->FE_367qam_CorrectedBitsNumber;
	if (Monitor_results->FE_367qam_Saturation > u32_tmp) {
		Monitor_results->FE_367qam_Saturation =
		    (9 * Monitor_results->FE_367qam_Saturation) / 10;
		Monitor_results->FE_367qam_Saturation += u32_tmp / 10;
	} else {
		Monitor_results->FE_367qam_Saturation =
		    (25 * Monitor_results->FE_367qam_Saturation) / 100;
		Monitor_results->FE_367qam_Saturation += (75 * u32_tmp) / 100;
	}
	if (Monitor_results->FE_367qam_Saturation > 65535)
		Monitor_results->FE_367qam_Saturation = 65535;

	return;
}

/*****************************************************
**FUNCTION	::	FE_367qam_GetBERCount
**ACTION	::	return 10^7*BER in u32 and BER in double format
**PARAMS IN	::	hChip		=>	Handle to the chip
**PARAMS IN ::	*Monitor_results => pointer to the counters structure
**PARAMS OUT::	NONE
**RETURN	::	None
*****************************************************/
void FE_367qam_GetBERCount(STCHIP_Handle_t hChip,
			   FE_367qam_Monitor *Monitor_results)
{
	U32 u32_tmp, NByte;

	ChipGetRegisters(hChip, R367qam_BERT_2, 2);
	u32_tmp =
	    ChipGetFieldImage(hChip,
			      F367qam_BERT_ERRCOUNT_L) +
	    (ChipGetFieldImage(hChip, F367qam_BERT_ERRCOUNT_H) << 8);
	if (ChipGetField(hChip, F367qam_BERT_ERR_MODE) == 0) {	/* rate mode */
		if (ChipGetField(hChip, F367qam_BERT_ON) == 0) {
			/* the previous count is finished */
			Monitor_results->FE_367qam_CorrectedBitsNumber =
			    u32_tmp;
			u32_tmp = ChipGetField(hChip, F367qam_BERT_NBYTE);
			NByte = PowOf2(2 * u32_tmp + 12);
			if (ChipGetField(hChip, F367qam_BERT_ERR_SRC) == 0) {
				/* bit count */
				Monitor_results->FE_367qam_BERxE7_u32 =
						(50000 * Monitor_results->
						FE_367qam_CorrectedBitsNumber);
				Monitor_results->FE_367qam_BERxE7_u32 /= NByte;
				Monitor_results->FE_367qam_BERxE7_u32 *= 25;
#ifdef HOST_PC
				Monitor_results->FE_367qam_BER_dbl =
				  (double)Monitor_results->
				  FE_367qam_CorrectedBitsNumber / (8 * NByte);
#endif
			} else {	/* byte count */

				Monitor_results->FE_367qam_BERxE7_u32 =
						(50000 * Monitor_results->
						 FE_367qam_CorrectedBitsNumber);
				Monitor_results->FE_367qam_BERxE7_u32 /= NByte;
				Monitor_results->FE_367qam_BERxE7_u32 *= 200;
#ifdef HOST_PC
				Monitor_results->FE_367qam_BER_dbl =
				    (double) Monitor_results->
				    FE_367qam_CorrectedBitsNumber / NByte;
#endif
			}
			/* Restart a new count */
			ChipSetField(hChip, F367qam_BERT_ON, 1);
		}
	} else {		/* Count mode */

		Monitor_results->FE_367qam_CorrectedBitsNumber = u32_tmp;
		Monitor_results->FE_367qam_BERxE7_u32 = u32_tmp;
#ifdef HOST_PC
		Monitor_results->FE_367qam_BER_dbl = (double)u32_tmp;
#endif
	}
	FE_367qam_SaturationComputation(Monitor_results);
	return;
}

void FE_367qam_OptimiseNByteAndGetBER(STCHIP_Handle_t hChip,
				      FE_CAB_Modulation_t QAMSize,
				      U32 SymbolRate_Bds,
				      FE_367qam_Monitor *Monitor_results)
{
	U32 WaitingTime, Saturation, NByte, i = 0;

	FE_367qam_GetWaitingTime(hChip, QAMSize, SymbolRate_Bds,
				 Monitor_results);
	FE_367qam_GetBERCount(hChip, Monitor_results);

	Saturation = Monitor_results->FE_367qam_Saturation;
	WaitingTime = Monitor_results->FE_367qam_WaitingTime_ms;
	NByte = ChipGetField(hChip, F367qam_BERT_NBYTE);

	while ((((Saturation < 100) && (NByte < 5))
		|| (((Saturation > 32768) || (WaitingTime > 3500))
		    && (NByte > 0))) && (i < 10)) {
		i++;
		if (((Saturation > 32768) || (WaitingTime > 3500))
		    && (NByte > 0)) {
			ChipSetField(hChip, F367qam_BERT_NBYTE, NByte - 1);
			FE_367qam_GetWaitingTime(hChip, QAMSize, SymbolRate_Bds,
						 Monitor_results);
			WaitingTime = Monitor_results->FE_367qam_WaitingTime_ms;
			if (WaitingTime < 200)
				ChipSetField(hChip, F367qam_BERT_NBYTE, NByte);
		}
		if ((Saturation < 100) && (NByte < 5)) {
			ChipSetField(hChip, F367qam_BERT_NBYTE, NByte + 1);
			FE_367qam_GetWaitingTime(hChip, QAMSize, SymbolRate_Bds,
						 Monitor_results);
			WaitingTime = Monitor_results->FE_367qam_WaitingTime_ms;
			if (WaitingTime > 3500)
				ChipSetField(hChip, F367qam_BERT_NBYTE, NByte);
		}
		FE_367qam_GetWaitingTime(hChip, QAMSize, SymbolRate_Bds,
					 Monitor_results);
		FE_367qam_GetBERCount(hChip, Monitor_results);
		Saturation = Monitor_results->FE_367qam_Saturation;
		WaitingTime = Monitor_results->FE_367qam_WaitingTime_ms;
		NByte = ChipGetField(hChip, F367qam_BERT_NBYTE);
	}
	return;
}

 /**/
void FE_367qam_GetPacketsCount(STCHIP_Handle_t hChip,
				   FE_367qam_Monitor *Monitor_results)
{
	U32 u32_tmp = 0;

	ChipSetField(hChip, F367qam_CT_HOLD, 1);
	ChipGetRegisters(hChip, R367qam_RS_COUNTER_0, 6);
	u32_tmp =
	    ChipGetFieldImage(hChip, F367qam_BK_CT_L) +
			       (ChipGetFieldImage(hChip, F367qam_BK_CT_H) << 8);
	if (Monitor_results->FE_367qam_TotalPacketsNumberOld > u32_tmp)
		Monitor_results->FE_367qam_TotalPacketsNumberOffset += 65536;
	Monitor_results->FE_367qam_TotalPacketsNumberOld = u32_tmp;
	Monitor_results->FE_367qam_TotalPacketsNumber =
	    Monitor_results->FE_367qam_TotalPacketsNumberOffset + u32_tmp;
	 /**/ u32_tmp =
	    ChipGetFieldImage(hChip, F367qam_CORR_CT_L) +
			     (ChipGetFieldImage(hChip, F367qam_CORR_CT_H) << 8);
	if (Monitor_results->FE_367qam_CorrectedPacketsNumberOld > u32_tmp)
		Monitor_results->FE_367qam_CorrectedPacketsNumberOffset +=
		    65536;
	Monitor_results->FE_367qam_CorrectedPacketsNumberOld = u32_tmp;
	Monitor_results->FE_367qam_CorrectedPacketsNumber =
	    Monitor_results->FE_367qam_CorrectedPacketsNumberOffset + u32_tmp;
	 /**/ u32_tmp =
	    ChipGetFieldImage(hChip, F367qam_UNCORR_CT_L) +
			   (ChipGetFieldImage(hChip, F367qam_UNCORR_CT_H) << 8);
	if (Monitor_results->FE_367qam_CorruptedPacketsNumberOld > u32_tmp)
		Monitor_results->FE_367qam_CorruptedPacketsNumberOffset +=
		    65536;
	Monitor_results->FE_367qam_CorruptedPacketsNumberOld = u32_tmp;
	Monitor_results->FE_367qam_CorruptedPacketsNumber =
	    Monitor_results->FE_367qam_CorruptedPacketsNumberOffset + u32_tmp;
	ChipSetField(hChip, F367qam_CT_HOLD, 0);

	if (Monitor_results->FE_367qam_TotalPacketsNumber != 0) {
		Monitor_results->FE_367qam_PERxE7_u32 =
		    (10000000 *
		     Monitor_results->FE_367qam_CorruptedPacketsNumber) /
		    (Monitor_results->FE_367qam_TotalPacketsNumber);
#ifdef HOST_PC
		Monitor_results->FE_367qam_PER_dbl =
		    (double)Monitor_results->FE_367qam_CorruptedPacketsNumber /
		    (double)Monitor_results->FE_367qam_TotalPacketsNumber;
#endif
	} else {
		Monitor_results->FE_367qam_PERxE7_u32 = 1;
#ifdef HOST_PC
		Monitor_results->FE_367qam_PER_dbl = 1.0;
#endif
	}
	return;
}

/*****************************************************
**FUNCTION	::	FE_367qam_GetErrorCount
**ACTION	::	return the number of error
**PARAMS IN	::	hChip		=>	Handle to the chip
**PARAMS IN ::	*Monitor_results => pointer to the counters structure
**PARAMS OUT::	NONE
**RETURN	::	None
*****************************************************/
void FE_367qam_GetErrorCount(STCHIP_Handle_t hChip, FE_CAB_Modulation_t QAMSize,
			     U32 SymbolRate_Bds,
			     FE_367qam_Monitor *Monitor_results)
{
	FE_367qam_OptimiseNByteAndGetBER(hChip, QAMSize, SymbolRate_Bds,
					 Monitor_results);
	FE_367qam_GetPacketsCount(hChip, Monitor_results);

	return;
}

/*
Clears all the Counters
*/
void FE_367qam_ClearCounters(STCHIP_Handle_t hChip,
			     FE_367qam_Monitor *Monitor_results)
{
	/* Clear blocks counters */
	ChipSetOneRegister(hChip, R367qam_BERT_0, 0x00);
	/* Enable block counters */
	ChipSetOneRegister(hChip, R367qam_BERT_0, 0x01);

	Monitor_results->FE_367qam_TotalPacketsNumber = 0;
	Monitor_results->FE_367qam_TotalPacketsNumberOld = 0;
	Monitor_results->FE_367qam_TotalPacketsNumberOffset = 0;
	Monitor_results->FE_367qam_CorrectedPacketsNumber = 0;
	Monitor_results->FE_367qam_CorrectedPacketsNumberOld = 0;
	Monitor_results->FE_367qam_CorrectedPacketsNumberOffset = 0;
	Monitor_results->FE_367qam_CorruptedPacketsNumber = 0;
	Monitor_results->FE_367qam_CorruptedPacketsNumberOld = 0;
	Monitor_results->FE_367qam_CorruptedPacketsNumberOffset = 0;
	Monitor_results->FE_367qam_CorrectedBitsNumber = 0;
	Monitor_results->FE_367qam_BERxE7_u32 = 0;
	Monitor_results->FE_367qam_Saturation = 0;
	Monitor_results->FE_367qam_WaitingTime_ms = 0;
	Monitor_results->FE_367qam_PERxE7_u32 = 0;
#ifdef HOST_PC
	Monitor_results->FE_367qam_BER_dbl = 0.0;
	Monitor_results->FE_367qam_PER_dbl = 0.0;
#endif
	/* restart a new BER count */
	ChipSetField(hChip, F367qam_BERT_ON, 0);
	/* restart a new BER count */
	ChipSetField(hChip, F367qam_BERT_ON, 1);

}

void FE_367qam_GetRFLevel(STCHIP_Handle_t hChip, STCHIP_Handle_t hTuner,
			  FE_367qam_Monitor *Monitor_results)
{
	S32 rfLevel = 0;
	S32 RfAgcPwm = 0, IfAgcPwm = 0;
	U8 i = 0;
	S32 Rf_TunerEstimated = 0;

	ChipSetField(hChip, F367qam_STDBY_ADCGP, 0x0);
	ChipGetRegisters(hChip, R367qam_RF_AGC1, 2);
	ChipGetRegisters(hChip, R367qam_AGC_PWM_IFCMD_L, 2);

	RfAgcPwm =
	    (ChipGetFieldImage(hChip, F367qam_RF_AGC1_LEVEL_LO) & 0x03) +
	    (ChipGetFieldImage(hChip, F367qam_RF_AGC1_LEVEL_HI) << 2);
	RfAgcPwm = 100 * RfAgcPwm / 1023;

	IfAgcPwm =
	    ChipGetFieldImage(hChip,
			      F367qam_AGC_IF_PWMCMD_LO) +
	    (ChipGetFieldImage(hChip, F367qam_AGC_IF_PWMCMD_HI) << 8);
	if (IfAgcPwm >= 2048)
		IfAgcPwm -= 2048;
	else
		IfAgcPwm += 2048;

	IfAgcPwm = 100 * IfAgcPwm / 4095;

	switch (FE_TunerGetModelName(hTuner)) {
	case TUNER_TDA18212:
		Rf_TunerEstimated = FE_TunerGetRFLevel(hTuner, 0, 0) / (-1);

		if (Rf_TunerEstimated < 65 && IfAgcPwm < 15) {
			for (i = 0; i < RF_LOOKUP_Tda18212_TABLE1_SIZE; i++) {
				if (Rf_TunerEstimated <=
				    FE_367qam_Tda18212_RF_LookUp1[0][i]) {
					rfLevel =
					    (-1) *
					    FE_367qam_Tda18212_RF_LookUp1[1][i];
					break;
				}
			}
			if (i == RF_LOOKUP_Tda18212_TABLE1_SIZE)
				rfLevel = -65;
		} else {
			for (i = 0; i < RF_LOOKUP_Tda18212_TABLE2_SIZE; i++) {
				if (IfAgcPwm <=
				    FE_367qam_Tda18212_RF_LookUp2[0][i]) {
					rfLevel =
					    (-1) *
					    FE_367qam_Tda18212_RF_LookUp2[1][i];
					break;
				}
			}
			if (i == RF_LOOKUP_Tda18212_TABLE2_SIZE)
				rfLevel = -90;
		}
		break;
	case TUNER_DTT7546:
	default:
		/* For DTT75467 on NIM */
		if (RfAgcPwm < 90 && IfAgcPwm < 28) {
			for (i = 0; i < RF_LOOKUP_TABLE_SIZE; i++) {
				if (RfAgcPwm <= FE_367qam_RF_LookUp1[0][i]) {
					rfLevel =
					    (-1) * FE_367qam_RF_LookUp1[1][i];
					break;
				}
			}
			if (i == RF_LOOKUP_TABLE_SIZE)
				rfLevel = -56;
		} else {
			for (i = 0; i < RF_LOOKUP_TABLE2_SIZE; i++) {
				if (IfAgcPwm <= FE_367qam_RF_LookUp2[0][i]) {
					rfLevel =
					    (-1) * FE_367qam_RF_LookUp2[1][i];
					break;
				}
			}
			if (i == RF_LOOKUP_TABLE2_SIZE)
				rfLevel = -72;
		}
		break;
	}

	Monitor_results->FE_367qam_RFLevelx10dBm_s32 = rfLevel;
	Monitor_results->FE_367qam_RFLevelx100Percent_u32 =
	    (U32) (2 * rfLevel + 144);
#ifdef HOST_PC
	Monitor_results->FE_367qam_RFLeveldBm_dbl = (double)rfLevel;
#endif

	return;
}

/*****************************************************
--FUNCTION	::	FE_367qam_GetCarrierToNoiseRatio_u32
--ACTION	::	Return the carrier to noise of the current
			carrier in integer
--PARAMS IN	::	NONE
--PARAMS OUT::	NONE
--RETURN	::	C/N of the carrier, 0 if no carrier
--***************************************************/
void FE_367qam_GetCarrierToNoiseRatio_u32(STCHIP_Handle_t hChip,
					  FE_367qam_Monitor *Monitor_results,
					  FE_CAB_Modulation_t QAMSize)
{
	U32 noisedb = 0, noisepercentage;

	U32 regval = 0, temp = 0;
	int power, i;
	switch (QAMSize) {
	case FE_CAB_MOD_QAM4:
		power = 21904;
		break;
	case FE_CAB_MOD_QAM16:
		power = 20480;
		break;
	case FE_CAB_MOD_QAM32:
		power = 23040;
		break;
	case FE_CAB_MOD_QAM64:
		power = 21504;
		break;
	case FE_CAB_MOD_QAM128:
		power = 23616;
		break;
	case FE_CAB_MOD_QAM256:
		power = 21760;
		break;
	case FE_CAB_MOD_QAM512:
		power = 1;
		break;
	case FE_CAB_MOD_QAM1024:
		power = 21280;
		break;
	default:
		power = 1;
		break;
	}
	for (i = 0; i < 10; i++) {
		regval +=
		    (ChipGetField(hChip, F367qam_SNR_LO) +
		     256 * ChipGetField(hChip, F367qam_SNR_HI));
	}
	if (regval != 0) {
		regval /= 10;	/*for average over 10 times in for loop above */
		temp = power * PowOf2(3 + ChipGetField(hChip, F367qam_SNR_PER));
		temp /= regval;
		/*#ifdef ST_OSLINUX */
		noisedb = (U32) ((10 * Log10Int(temp)) / 16777216);
		/*#else */
		/*noisedb = (U32)(10*log10(temp)); */
		/*#endif */
	} else
		noisedb = 38;	/*no noise! */

	if (noisedb >= 37)
		/* C/N 21dB is reference going till 48dB for QAM64 */
		noisepercentage = 100;
	else if (noisedb >= 36)
		noisepercentage = 93;
	else if (noisedb >= 35)
		noisepercentage = 86;
	else if (noisedb >= 34)
		noisepercentage = 79;
	else if (noisedb >= 33)
		noisepercentage = 72;
	else if (noisedb >= 32)
		noisepercentage = 65;
	else if (noisedb >= 31)
		noisepercentage = 58;
	else if (noisedb >= 30)
		noisepercentage = 50;
	else if (noisedb >= 29)
		noisepercentage = 43;
	else if (noisedb >= 27)
		noisepercentage = 36;
	else if (noisedb >= 25)
		noisepercentage = 29;
	else if (noisedb >= 23)
		noisepercentage = 22;
	else if (noisedb >= 22)
		noisepercentage = 14;
	else if (noisedb >= 21)
		noisepercentage = 7;
	else
		noisepercentage = 0;

	Monitor_results->FE_367qam_SNRx10dB_u32 = 10 * noisedb;
	Monitor_results->FE_367qam_SNRx100Percent_u32 = noisepercentage;
	return;

	/*
	C/N(Mod)     C/N(Measured)     Q
	Off            38
	48             38             100%

	46             37              93

	44             36              86

	42             35              79

	40             34              72

	38             33              65

	36             32              58

	34             31              50

	32             30              43

	30             29              36

	28		27             29

	26             25              22

	24             23              15
	23             22
	22.7           22              07
	xxx            21              0%
	 */

}

#ifdef HOST_PC
/*****************************************************
--FUNCTION	::	FE_367qam_GetCarrierToNoiseRatio_dbl
--ACTION	::	Return the carrier to noise of the current
			carrier in double
--PARAMS IN	::	NONE
--PARAMS OUT::	NONE
--RETURN	::	C/N of the carrier, 0 if no carrier
--***************************************************/
void FE_367qam_GetCarrierToNoiseRatio_dbl(STCHIP_Handle_t hChip,
					  FE_367qam_Monitor *Monitor_results,
					  FE_CAB_Modulation_t QAMSize)
{
	U32 regval = 0;
	double noisedb = 0;
	long power;

	switch (ChipGetField(hChip, F367qam_QAM_MODE)) {
	case 0:
		power = 21904;
		break;
	case 1:
		power = 20480;
		break;
	case 2:
		power = 23040;
		break;
	case 3:
		power = 21504;
		break;
	case 4:
		power = 23616;
		break;
	case 5:
		power = 21760;
		break;
	case 6:
		power = 1;
		break;
	case 7:
		power = 21280;
		break;
	default:
		power = 1;
		break;
	}

	ChipGetRegisters(hChip, R367qam_EQU_SNR_LO, 2);
	regval =
	    ChipGetFieldImage(hChip, F367qam_SNR_LO) + 256 *
				       ChipGetFieldImage(hChip, F367qam_SNR_HI);
	if (regval != 0)
		noisedb = -10.0 * log10((double)regval / ((double)(power *
			PowOf2(3 + ChipGetField(hChip, F367qam_SNR_PER)))));
	else
		noisedb = 50.0;

	Monitor_results->FE_367qam_SNRdB_dbl = noisedb;
	return;
}
#endif
/*****************************************************
--FUNCTION	::	FE_367qam_Init
--ACTION	::	Initialisation of the STV0367QAM chip
--PARAMS IN	::	pInit	==> pointer to FE_367qam_InitParams_t structure
		::	Handle  ==> pointer to the demod front - end handle
--PARAMS OUT::	NONE
--RETURN	::	None
--***************************************************/
FE_LLA_Error_t FE_367qam_Init(FE_CAB_InitParams_t *pInit,
			      FE_367qam_Handle_t *Handle)
{
	FE_367qam_InternalParams_t *pParams = NULL;

	FE_LLA_Error_t error = FE_LLA_NO_ERROR;
	/* Internal params structure allocation */
#ifdef HOST_PC
#ifdef NO_GUI
	STCHIP_Info_t DemodChip;
	/* Demodulator chip initialisation parameters */
	Demod_InitParams_t DemodInitParams;
	DemodInitParams.Chip = &DemodChip;
#endif
	pParams = calloc(1, sizeof(FE_367qam_InternalParams_t));
	(*Handle) = (FE_367qam_Handle_t) pParams;
#endif
#ifdef CHIP_STAPI
	pParams = (FE_367qam_InternalParams_t *) (*Handle);
#endif

	if (pParams != NULL && pParams->hDemod != NULL) {
		/* Chip initialisation */
#if defined(HOST_PC) && !defined(NO_GUI)
		/* use current selected 367qam */
		pParams->hDemod = DEMOD;
		pParams->hTuner = TUNER;
		pParams->hTuner2 = TUNER_B;
		pParams->Crystal_Hz = EXTCLK;
#else
		TUNER_InitParams_t TunerInitParams;
		STCHIP_Error_t DemodError = CHIPERR_NO_ERROR;
		TUNER_Error_t TunerError = TUNER_NO_ERR;
		TUNER_Error_t Tuner2Error = TUNER_NO_ERR;
		/* Demodulator(STv0367qam) */
#ifdef CHIP_STAPI
		/* Demodulator chip initialisation parameters */
		Demod_InitParams_t DemodInitParams;
		DemodInitParams.Chip = (pParams->hDemod);
#endif
		DemodInitParams.Chip->RepeaterHost = NULL;
		DemodInitParams.Chip->Repeater = FALSE;
		DemodInitParams.Chip->pData = NULL;
		DemodInitParams.Chip->I2cAddr = pInit->DemodI2cAddr;
		strcpy((char *)DemodInitParams.Chip->Name,
		       (char *)(pInit->DemodName));
		/* Create a new 367qam chip */
		DemodError = STV0367qam_Init(&DemodInitParams,
						&pParams->hDemod);
		pParams->Crystal_Hz = pInit->DemodXtal_Hz;
#endif

		if ((pParams->hDemod != NULL) && (!pParams->hDemod->Error)) {
			pParams->IF_Freq_kHz = pInit->TunerIF_kHz;
#if defined(CHIP_STAPI) || defined(NO_GUI)
			switch (pInit->TS_Config.TSClockPolarity) {
			case FE_TS_RISINGEDGE_CLOCK:
				ChipSetField(pParams->hDemod,
					     F367qam_CLK_POLARITY, 0x01);
				break;
			case FE_TS_FALLINGEDGE_CLOCK:
			case FE_TS_CLOCKPOLARITY_DEFAULT:
				ChipSetField(pParams->hDemod,
					     F367qam_CLK_POLARITY, 0x00);
				break;
			}
			switch (pInit->TS_Config.TSSyncByteEnable) {
			case FE_TS_SYNCBYTE_OFF:
				ChipSetField(pParams->hDemod,
					     F367qam_SYNC_STRIP, 0x01);
				break;
			case FE_TS_SYNCBYTE_ON:
			case FE_TS_SYNCBYTE_DEFAULT:
				ChipSetField(pParams->hDemod,
					     F367qam_SYNC_STRIP, 0X00);
				break;
			}
			switch (pInit->TS_Config.TSParityBytes) {
			case FE_TS_PARITYBYTES_ON:
				ChipSetField(pParams->hDemod, F367qam_CT_NBST,
					     0x01);
				break;
			case FE_TS_PARITYBYTES_OFF:
			case FE_TS_PARTITYBYTES_DEFAULT:
				ChipSetField(pParams->hDemod, F367qam_CT_NBST,
					     0x00);
				break;
			}
			switch (pInit->TS_Config.TSSwap) {
			case FE_TS_SWAP_ON:
				/* Serial output on D0    */
				ChipSetField(pParams->hDemod, F367qam_TS_SWAP,
						0x00);
				break;
			case FE_TS_SWAP_OFF:
			case FE_TS_SWAP_DEFAULT:
				/* Serial output on D7    */
				ChipSetField(pParams->hDemod, F367qam_TS_SWAP,
						0x01);
				break;
			}
			switch (pInit->TS_Config.TSSmoother) {
			case FE_TS_SMOOTHER_ON:
				/* TSFIFO Enabled */
				ChipSetField(pParams->hDemod,
						F367qam_FIFO_BYPASS, 0x01);
				break;
			case FE_TS_SMOOTHER_OFF:
			case FE_TS_SMOOTHER_DEFAULT:
				/* TSFIFO Bypassed */
				ChipSetField(pParams->hDemod,
						F367qam_FIFO_BYPASS, 0x00);
				break;
			}
			switch (pInit->TS_Config.TSMode) {
			case FE_TS_DVBCI_CLOCK:
				ChipSetField(pParams->hDemod, F367qam_OUTFORMAT,
					     0x03);
				ChipSetField(pParams->hDemod, F367qam_TS_SWAP,
					     0x00);
				break;
			case FE_TS_SERIAL_PUNCT_CLOCK:
			case FE_TS_SERIAL_CONT_CLOCK:
				ChipSetField(pParams->hDemod, F367qam_OUTFORMAT,
					     0x01);
				break;
			case FE_TS_PARALLEL_PUNCT_CLOCK:
			case FE_TS_OUTPUTMODE_DEFAULT:
				ChipSetField(pParams->hDemod, F367qam_OUTFORMAT,
					     0x00);
				ChipSetField(pParams->hDemod, F367qam_TS_SWAP,
					     0x00);
				break;
			}

			/* Here we make the necessary changes to the demod's
			 * registers depending on the tuner */
			switch (pInit->TunerModel) {
			case TUNER_DNOS40AS:
				/* PLL bypassed and disabled */
				ChipSetOneRegister(pParams->hDemod,
						R367qam_ANACTRL, 0x0D);
				/* IC runs at 54MHz with a 27MHz crystal */
				ChipSetOneRegister(pParams->hDemod,
						R367qam_PLLMDIV, 0x01);
				ChipSetOneRegister(pParams->hDemod,
						   R367qam_PLLNDIV, 0x08);
				/* ADC clock is equal to system clock */
				ChipSetOneRegister(pParams->hDemod,
						R367qam_PLLSETUP, 0x18);
				/* PLL enabled and used */
				ChipSetOneRegister(pParams->hDemod,
						R367qam_ANACTRL, 0x00);
				/* Buffer Q disabled */
				ChipSetOneRegister(pParams->hDemod,
						R367qam_ANADIGCTRL, 0x0b);
				/* ADCQ disabled */
				ChipSetOneRegister(pParams->hDemod,
						R367qam_DUAL_AD12, 0x04);
				/* Improves the C/N lock limit */
				ChipSetOneRegister(pParams->hDemod,
						R367qam_FSM_SNR2_HTH, 0x23);
				/* ZIF/IF Automatic mode */
				ChipSetOneRegister(pParams->hDemod,
						R367qam_IQ_QAM, 0x01);
				/* I2C repeater configuration, value changes
				 * with I2C master clock */
				ChipSetOneRegister(pParams->hDemod,
						R367qam_I2CRPT, 0x22);
				ChipSetOneRegister(pParams->hDemod,
						   R367qam_EQU_FFE_LEAKAGE,
						   0x63);
				ChipSetOneRegister(pParams->hDemod,
						   R367qam_IQDEM_ADJ_EN, 0x04);
				break;
			case TUNER_DTT7546:
				/* PLL bypassed and disabled */
				ChipSetOneRegister(pParams->hDemod,
						R367qam_ANACTRL, 0x0D);
				/* IC runs at 54MHz with a 27MHz crystal */
				ChipSetOneRegister(pParams->hDemod,
						R367qam_PLLMDIV, 0x01);
				ChipSetOneRegister(pParams->hDemod,
						   R367qam_PLLNDIV, 0x08);
				/* ADC clock is equal to system clock */
				ChipSetOneRegister(pParams->hDemod,
						R367qam_PLLSETUP, 0x18);
				/* PLL enabled and used */
				ChipSetOneRegister(pParams->hDemod,
						R367qam_ANACTRL, 0x00);
				/* Buffer Q disabled */
				ChipSetOneRegister(pParams->hDemod,
						R367qam_ANADIGCTRL, 0x0b);
				/* ADCQ disabled */
				ChipSetOneRegister(pParams->hDemod,
						R367qam_DUAL_AD12, 0x04);
				/* Improves the C/N lock limit */
				ChipSetOneRegister(pParams->hDemod,
						R367qam_FSM_SNR2_HTH, 0x23);
				/* ZIF/IF Automatic mode */
				ChipSetOneRegister(pParams->hDemod,
						R367qam_IQ_QAM, 0x01);
				/* I2C repeater configuration, value changes
				 * with I2C master clock */
				ChipSetOneRegister(pParams->hDemod,
						R367qam_I2CRPT, 0x22);
				ChipSetOneRegister(pParams->hDemod,
						   R367qam_EQU_FFE_LEAKAGE,
						   0x63);
				ChipSetOneRegister(pParams->hDemod,
						   R367qam_IQDEM_ADJ_EN, 0x04);
				break;
			case TUNER_STV4100:
				/* PLL bypassed and disabled */
				ChipSetOneRegister(pParams->hDemod,
						R367qam_ANACTRL, 0x0D);
				/* IC runs at 58.5MHz with a 30MHz crystal */
				ChipSetOneRegister(pParams->hDemod,
						R367qam_PLLMDIV, 0x0A);
				ChipSetOneRegister(pParams->hDemod,
						   R367qam_PLLNDIV, 0x4E);
				/* ADC clock is equal to system clock */
				ChipSetOneRegister(pParams->hDemod,
						R367qam_PLLSETUP, 0x18);
				/* PLL enabled and used */
				ChipSetOneRegister(pParams->hDemod,
						R367qam_ANACTRL, 0x00);
				/* Buffer Q enabled */
				ChipSetOneRegister(pParams->hDemod,
						R367qam_ANADIGCTRL, 0x1b);
				/* ADCQ enabled */
				ChipSetOneRegister(pParams->hDemod,
						R367qam_DUAL_AD12, 0x00);
				/* Improves the C/N lock limit */
				ChipSetOneRegister(pParams->hDemod,
						R367qam_FSM_SNR2_HTH, 0x23);
				/* ZIF/IF Automatic mode */
				ChipSetOneRegister(pParams->hDemod,
						R367qam_IQ_QAM, 0x01);
				/* I2C repeater configuration, value changes
				 * with I2C master clock */
				ChipSetOneRegister(pParams->hDemod,
						R367qam_I2CRPT, 0x22);
				ChipSetOneRegister(pParams->hDemod,
						   R367qam_EQU_FFE_LEAKAGE,
						   0x63);
				ChipSetOneRegister(pParams->hDemod,
						   R367qam_IQDEM_ADJ_EN, 0x04);
				break;
			case TUNER_DCT70700:
				/* PLL bypassed and disabled */
				ChipSetOneRegister(pParams->hDemod,
						R367qam_ANACTRL, 0x0D);
				/* IC runs at 54MHz with a 30MHz crystal */
				ChipSetOneRegister(pParams->hDemod,
						R367qam_PLLMDIV, 0x05);
				ChipSetOneRegister(pParams->hDemod,
						   R367qam_PLLNDIV, 0x24);
				/* ADC clock is equal to system clock */
				ChipSetOneRegister(pParams->hDemod,
						R367qam_PLLSETUP, 0x18);
				/* PLL enabled and used */
				ChipSetOneRegister(pParams->hDemod,
						R367qam_ANACTRL, 0x00);
				/* Buffer Q disabled */
				ChipSetOneRegister(pParams->hDemod,
						R367qam_ANADIGCTRL, 0x0b);
				/* ADCQ disabled */
				ChipSetOneRegister(pParams->hDemod,
						R367qam_DUAL_AD12, 0x04);
				/* Improves the C/N lock limit */
				ChipSetOneRegister(pParams->hDemod,
						R367qam_FSM_SNR2_HTH, 0x23);
				/* ZIF/IF Automatic mode */
				ChipSetOneRegister(pParams->hDemod,
						R367qam_IQ_QAM, 0x01);
				/* I2C repeater configuration, value changes
				 * with I2C master clock */
				ChipSetOneRegister(pParams->hDemod,
						R367qam_I2CRPT, 0x22);
				/* Improving burst noise performances */
				ChipSetOneRegister(pParams->hDemod,
						R367qam_EQU_FFE_LEAKAGE, 0x83);
				/* Improving ACI performances */
				ChipSetOneRegister(pParams->hDemod,
						R367qam_IQDEM_ADJ_EN, 0x05);
				break;
			case TUNER_MXL203RF:
				/* PLL bypassed and disabled */
				ChipSetOneRegister(pParams->hDemod,
						R367qam_ANACTRL, 0x0D);
				/* IC runs at 54MHz with a 30MHz crystal */
				ChipSetOneRegister(pParams->hDemod,
						R367qam_PLLMDIV, 0x05);
				ChipSetOneRegister(pParams->hDemod,
						   R367qam_PLLNDIV, 0x24);
				/* ADC clock is equal to system clock */
				ChipSetOneRegister(pParams->hDemod,
						R367qam_PLLSETUP, 0x18);
				/* PLL enabled and used */
				ChipSetOneRegister(pParams->hDemod,
						R367qam_ANACTRL, 0x00);
				/* Buffer Q disabled */
				ChipSetOneRegister(pParams->hDemod,
						R367qam_ANADIGCTRL, 0x0b);
				/* ADCQ disabled */
				ChipSetOneRegister(pParams->hDemod,
						R367qam_DUAL_AD12, 0x04);
				/* Improves the C/N lock limit */
				ChipSetOneRegister(pParams->hDemod,
						R367qam_FSM_SNR2_HTH, 0x23);
				/* ZIF/IF Automatic mode */
				ChipSetOneRegister(pParams->hDemod,
						R367qam_IQ_QAM, 0x01);
				/* I2C repeater configuration, value changes
				 * with I2C master clock */
				ChipSetOneRegister(pParams->hDemod,
						R367qam_I2CRPT, 0x22);
				/* Improving burst noise performances */
				ChipSetOneRegister(pParams->hDemod,
						R367qam_EQU_FFE_LEAKAGE, 0x83);
				/* Improving ACI performances */
				ChipSetOneRegister(pParams->hDemod,
						R367qam_IQDEM_ADJ_EN, 0x05);
				break;
			case TUNER_TDCCG:
				/* PLL bypassed and disabled */
				ChipSetOneRegister(pParams->hDemod,
						R367qam_ANACTRL, 0x0D);
				/* IC runs at 54MHz with a 30MHz crystal */
				ChipSetOneRegister(pParams->hDemod,
						R367qam_PLLMDIV, 0x05);
				ChipSetOneRegister(pParams->hDemod,
						   R367qam_PLLNDIV, 0x24);
				/* ADC clock is equal to system clock */
				ChipSetOneRegister(pParams->hDemod,
						R367qam_PLLSETUP, 0x18);
				/* PLL enabled and used */
				ChipSetOneRegister(pParams->hDemod,
						R367qam_ANACTRL, 0x00);
				/* Buffer Q disabled */
				ChipSetOneRegister(pParams->hDemod,
						R367qam_ANADIGCTRL, 0x0b);
				/* ADCQ disabled */
				ChipSetOneRegister(pParams->hDemod,
						R367qam_DUAL_AD12, 0x04);
				/* Improves the C/N lock limit */
				ChipSetOneRegister(pParams->hDemod,
						R367qam_FSM_SNR2_HTH, 0x23);
				/* ZIF/IF Automatic mode */
				ChipSetOneRegister(pParams->hDemod,
						R367qam_IQ_QAM, 0x01);
				/* I2C repeater configuration, value changes
				 * with I2C master clock */
				ChipSetOneRegister(pParams->hDemod,
						R367qam_I2CRPT, 0x22);
				/* Improving burst noise performances */
				ChipSetOneRegister(pParams->hDemod,
						R367qam_EQU_FFE_LEAKAGE, 0x83);
				/* Improving ACI performances */
				ChipSetOneRegister(pParams->hDemod,
						R367qam_IQDEM_ADJ_EN, 0x05);
				break;
			case TUNER_CD1616LF:
				/* PLL bypassed and disabled */
				ChipSetOneRegister(pParams->hDemod,
						R367qam_ANACTRL, 0x0D);
				/* IC runs at 54MHz with a 30MHz crystal */
				ChipSetOneRegister(pParams->hDemod,
						R367qam_PLLMDIV, 0x05);
				ChipSetOneRegister(pParams->hDemod,
						   R367qam_PLLNDIV, 0x24);
				/* ADC clock is equal to system clock */
				ChipSetOneRegister(pParams->hDemod,
						R367qam_PLLSETUP, 0x18);
				/* PLL enabled and used */
				ChipSetOneRegister(pParams->hDemod,
						R367qam_ANACTRL, 0x00);
				/* Buffer Q disabled */
				ChipSetOneRegister(pParams->hDemod,
						R367qam_ANADIGCTRL, 0x0b);
				/* ADCQ disabled */
				ChipSetOneRegister(pParams->hDemod,
						R367qam_DUAL_AD12, 0x04);
				/* Improves the C/N lock limit */
				ChipSetOneRegister(pParams->hDemod,
						R367qam_FSM_SNR2_HTH, 0x23);
				/* ZIF/IF Automatic mode */
				ChipSetOneRegister(pParams->hDemod,
						R367qam_IQ_QAM, 0x01);
				/* I2C repeater configuration, value changes
				 * with I2C master clock */
				ChipSetOneRegister(pParams->hDemod,
						R367qam_I2CRPT, 0x22);
				/* Improving burst noise performances */
				ChipSetOneRegister(pParams->hDemod,
						R367qam_EQU_FFE_LEAKAGE, 0x83);
				/* redefined in setQAMsize xin V1.3 09/12/09 */
				/* Improving ACI performances */
				/*ChipSetOneRegister(pParams->hDemod,
						R367qam_IQDEM_ADJ_EN, 0x05); */
				break;
			case TUNER_FQD1116:
				/* THIS IS NOT AN OPTIMIZED SETTING. TVDIV
				 * WANTED SMTH QUICKLY */
				/* PLL bypassed and disabled */
				ChipSetOneRegister(pParams->hDemod,
						R367qam_ANACTRL, 0x0D);
				/* IC runs at 54MHz with a 27MHz crystal */
				ChipSetOneRegister(pParams->hDemod,
						R367qam_PLLMDIV, 0x01);
				ChipSetOneRegister(pParams->hDemod,
						   R367qam_PLLNDIV, 0x08);
				/* ADC clock is equal to system clock */
				ChipSetOneRegister(pParams->hDemod,
						R367qam_PLLSETUP, 0x18);
				/* PLL enabled and used */
				ChipSetOneRegister(pParams->hDemod,
						R367qam_ANACTRL, 0x00);
				/* Buffer Q disabled */
				ChipSetOneRegister(pParams->hDemod,
						R367qam_ANADIGCTRL, 0x0b);
				/* ADCQ disabled */
				ChipSetOneRegister(pParams->hDemod,
						R367qam_DUAL_AD12, 0x04);
				/* Improves the C/N lock limit */
				ChipSetOneRegister(pParams->hDemod,
						R367qam_FSM_SNR2_HTH, 0x23);
				/* ZIF/IF Automatic mode */
				ChipSetOneRegister(pParams->hDemod,
						R367qam_IQ_QAM, 0x01);
				/* I2C repeater configuration, value changes
				 * with I2C master clock */
				ChipSetOneRegister(pParams->hDemod,
						R367qam_I2CRPT, 0x22);
				ChipSetOneRegister(pParams->hDemod,
						   R367qam_EQU_FFE_LEAKAGE,
						   0x63);
				ChipSetOneRegister(pParams->hDemod,
						   R367qam_IQDEM_ADJ_EN, 0x04);
				break;
			case TUNER_MT2066:
				/* PLL bypassed and disabled */
				ChipSetOneRegister(pParams->hDemod,
						   R367qam_ANACTRL, 0x0D);
				/* IC runs at 54MHz with a 30MHz crystal */
				ChipSetOneRegister(pParams->hDemod,
						   R367qam_PLLMDIV, 0x05);
				ChipSetOneRegister(pParams->hDemod,
						   R367qam_PLLNDIV, 0x24);
				/* ADC clock is equal to system clock */
				ChipSetOneRegister(pParams->hDemod,
						   R367qam_PLLSETUP, 0x18);
				/* PLL enabled and used */
				ChipSetOneRegister(pParams->hDemod,
						   R367qam_ANACTRL, 0x00);
				/* Buffer Q disabled */
				ChipSetOneRegister(pParams->hDemod,
						   R367qam_ANADIGCTRL, 0x0b);
				/* ADCQ disabled */
				ChipSetOneRegister(pParams->hDemod,
						   R367qam_DUAL_AD12, 0x05);
				/* Improves the C/N lock limit */
				ChipSetOneRegister(pParams->hDemod,
						   R367qam_FSM_SNR2_HTH, 0x23);
				/* ZIF/IF Automatic mode */
				ChipSetOneRegister(pParams->hDemod,
						   R367qam_IQ_QAM, 0x01);
				/* I2C repeater configuration,
				 * value changes with I2C master clock */
				ChipSetOneRegister(pParams->hDemod,
						   R367qam_I2CRPT, 0x22);
				ChipSetOneRegister(pParams->hDemod,
						   R367qam_EQU_FFE_LEAKAGE,
						   0x83);
				ChipSetOneRegister(pParams->hDemod,
						   R367qam_IQDEM_ADJ_EN, 0x05);
				break;
			case TUNER_CD1100:
				ChipSetOneRegister(pParams->hDemod,
						   R367qam_GPIO_CMD, 0x01);
				/* PLL bypassed and disabled */
				ChipSetOneRegister(pParams->hDemod,
						   R367qam_ANACTRL, 0x0D);
				/* IC runs at 54MHz with a 30MHz crystal */
				ChipSetOneRegister(pParams->hDemod,
						   R367qam_PLLMDIV, 0x05);
				ChipSetOneRegister(pParams->hDemod,
						   R367qam_PLLNDIV, 0x24);
				/* ADC clock is equal to system clock */
				ChipSetOneRegister(pParams->hDemod,
						   R367qam_PLLSETUP, 0x18);
				/* PLL enabled and used */
				ChipSetOneRegister(pParams->hDemod,
						   R367qam_ANACTRL, 0x00);
				/* Buffer Q disabled */
				ChipSetOneRegister(pParams->hDemod,
						   R367qam_ANADIGCTRL, 0x0b);
				/* ADCQ disabled */
				ChipSetOneRegister(pParams->hDemod,
						   R367qam_DUAL_AD12, 0x05);
				/* Improves the C/N lock limit */
				ChipSetOneRegister(pParams->hDemod,
						   R367qam_FSM_SNR2_HTH, 0x23);
				/* ZIF/IF Automatic mode */
				ChipSetOneRegister(pParams->hDemod,
						   R367qam_IQ_QAM, 0x01);
				/* I2C repeater configuration,
				 * value changes with I2C master clock */
				ChipSetOneRegister(pParams->hDemod,
						   R367qam_I2CRPT, 0x22);
				ChipSetOneRegister(pParams->hDemod,
						   R367qam_EQU_FFE_LEAKAGE,
						   0x83);
				ChipSetOneRegister(pParams->hDemod,
						   R367qam_IQDEM_ADJ_EN, 0x05);
				break;
			case TUNER_TDA18250:
				ChipSetOneRegister(pParams->hDemod,
						   R367qam_ANACTRL, 0x0D);
				if (pParams->Crystal_Hz == 16000000) {
					ChipSetOneRegister(pParams->hDemod,
							   R367qam_PLLMDIV,
							   0x02);
					ChipSetOneRegister(pParams->hDemod,
							   R367qam_PLLNDIV,
							   0x1d);
				} else {
					ChipSetOneRegister(pParams->hDemod,
							   R367qam_PLLMDIV,
							   0x05);
					ChipSetOneRegister(pParams->hDemod,
							   R367qam_PLLNDIV,
							   0x24);
				}
				ChipSetOneRegister(pParams->hDemod,
						   R367qam_PLLSETUP, 0x18);
				ChipSetOneRegister(pParams->hDemod,
						   R367qam_ANACTRL, 0x00);
				ChipSetOneRegister(pParams->hDemod,
						   R367qam_ANADIGCTRL, 0x0b);
				ChipSetOneRegister(pParams->hDemod,
						   R367qam_DUAL_AD12, 0x04);
				ChipSetOneRegister(pParams->hDemod,
						   R367qam_FSM_SNR2_HTH, 0x23);
				ChipSetOneRegister(pParams->hDemod,
						   R367qam_I2CRPT, 0xb0);
				ChipSetOneRegister(pParams->hDemod,
						   R367qam_IQ_QAM, 0x01);
				ChipSetOneRegister(pParams->hDemod,
						   R367qam_EQU_FFE_LEAKAGE,
						   0x83);
				ChipSetOneRegister(pParams->hDemod,
						   R367qam_I2CRPT, 0x22);
				break;
			case TUNER_TDA18212:
				ChipSetOneRegister(pParams->hDemod,
						   R367qam_ANACTRL, 0x0D);
				ChipSetOneRegister(pParams->hDemod,
						   R367qam_PLLMDIV, 0x02);
				ChipSetOneRegister(pParams->hDemod,
						   R367qam_PLLNDIV, 0x1D);
				ChipSetOneRegister(pParams->hDemod,
						   R367qam_PLLSETUP, 0x18);
				ChipSetOneRegister(pParams->hDemod,
						   R367qam_ANACTRL, 0x00);
				ChipSetOneRegister(pParams->hDemod,
						   R367qam_ANADIGCTRL, 0x0a);
				ChipSetOneRegister(pParams->hDemod,
						   R367qam_DUAL_AD12, 0x04);
				ChipSetOneRegister(pParams->hDemod,
						   R367qam_FSM_SNR2_HTH, 0x23);
				ChipSetOneRegister(pParams->hDemod,
						   R367qam_IQ_QAM, 0x01);
				ChipSetOneRegister(pParams->hDemod,
						   R367qam_I2CRPT, 0xb0);
				ChipSetOneRegister(pParams->hDemod,
						   R367qam_EQU_FFE_LEAKAGE,
						   0x63);
				ChipSetOneRegister(pParams->hDemod,
						   R367qam_IQDEM_ADJ_EN, 0x04);
				ChipSetOneRegister(pParams->hDemod,
						   R367qam_I2CRPT, 0x32);
				break;
			case TUNER_TDA18219:
			case TUNER_TDA18250A:
				ChipSetOneRegister(pParams->hDemod,
						   R367qam_ANACTRL, 0x0D);
				ChipSetOneRegister(pParams->hDemod,
						   R367qam_PLLMDIV, 0x02);
				ChipSetOneRegister(pParams->hDemod,
						   R367qam_PLLNDIV, 0x1D);
				ChipSetOneRegister(pParams->hDemod,
						   R367qam_PLLSETUP, 0x18);
				ChipSetOneRegister(pParams->hDemod,
						   R367qam_ANACTRL, 0x00);
				ChipSetOneRegister(pParams->hDemod,
						   R367qam_ANADIGCTRL, 0x0a);
				ChipSetOneRegister(pParams->hDemod,
						   R367qam_DUAL_AD12, 0x04);
				ChipSetOneRegister(pParams->hDemod,
						   R367qam_FSM_SNR2_HTH, 0x23);
				ChipSetOneRegister(pParams->hDemod,
						   R367qam_IQ_QAM, 0x01);
				ChipSetOneRegister(pParams->hDemod,
						   R367qam_I2CRPT, 0xb0);
				ChipSetOneRegister(pParams->hDemod,
						   R367qam_EQU_FFE_LEAKAGE,
						   0x63);
				ChipSetOneRegister(pParams->hDemod,
						   R367qam_IQDEM_ADJ_EN, 0x04);
				ChipSetOneRegister(pParams->hDemod,
						   R367qam_I2CRPT, 0x32);
				break;
			case TUNER_MXL603:
				ChipSetOneRegister(pParams->hDemod,
						   R367qam_ANACTRL, 0x0D);
				ChipSetOneRegister(pParams->hDemod,
						   R367qam_PLLMDIV, 0x02);
				ChipSetOneRegister(pParams->hDemod,
						   R367qam_PLLNDIV, 0x1D);
				ChipSetOneRegister(pParams->hDemod,
						   R367qam_PLLSETUP, 0x18);
				ChipSetOneRegister(pParams->hDemod,
						   R367qam_ANACTRL, 0x00);
				ChipSetOneRegister(pParams->hDemod,
						   R367qam_ANADIGCTRL, 0x0a);
				ChipSetOneRegister(pParams->hDemod,
						   R367qam_DUAL_AD12, 0x04);
				ChipSetOneRegister(pParams->hDemod,
						   R367qam_FSM_SNR2_HTH, 0x23);
				ChipSetOneRegister(pParams->hDemod,
						   R367qam_IQ_QAM, 0x01);
				ChipSetOneRegister(pParams->hDemod,
						   R367qam_I2CRPT, 0xb0);
				ChipSetOneRegister(pParams->hDemod,
						   R367qam_EQU_FFE_LEAKAGE,
						   0x63);
				ChipSetOneRegister(pParams->hDemod,
						   R367qam_IQDEM_ADJ_EN, 0x04);
				ChipSetOneRegister(pParams->hDemod,
						   R367qam_I2CRPT, 0x32);
				break;
			default:
				break;
			}
			/* Tuner initialisation */
			/* This has to be done here because we need to
			 * configure the I2C repeater on the right GPIOs first
			 * before accessing the tuner */
			TunerInitParams.Model = pInit->TunerModel;
			TunerInitParams.TunerName = pInit->TunerName;
			strcpy((char *)TunerInitParams.TunerName,
			       pInit->TunerName);
			TunerInitParams.TunerI2cAddress = pInit->TunerI2cAddr;
			TunerInitParams.IF = pInit->TunerIF_kHz;
			TunerInitParams.RepeaterHost = pParams->hDemod;
			TunerInitParams.RepeaterFn = FE_367qam_Repeater;
			TunerInitParams.DemodModel = DEMOD_STV0367DVBC;
			TunerInitParams.Fxtal_Hz = pInit->TunerXtal_Hz;
			TunerInitParams.TransmitStandard = FE_DVB_C;
			TunerError =
			    FE_TunerInit(&TunerInitParams, &(pParams->hTuner));

			/* Note that the below tuner with handle
			 * hTuner2 is not a tuner but an analog
			 * demod needed in some cases only */
			if ((pInit->TunerModel == TUNER_FQD1116)
			    || (pInit->TunerModel == TUNER_DNOS40AS)) {
				TunerInitParams.Model = TUNER_TDA9898;
				TunerInitParams.TunerName = "TDA9898";
				strcpy((char *)TunerInitParams.TunerName,
				       "TDA9898");
				TunerInitParams.TunerI2cAddress =
				    pInit->TunerI2cAddr2;
				TunerInitParams.RepeaterHost = pParams->hDemod;
				TunerInitParams.RepeaterFn = FE_367qam_Repeater;
				TunerInitParams.DemodModel = DEMOD_STV0367DVBC;
				Tuner2Error =
				    FE_TunerInit(&TunerInitParams,
						 &(pParams->hTuner2));
			}
			if (DemodError == CHIPERR_NO_ERROR) {
				/* Check the demod error first */
				/* If no Error on the demod
				 * then check the Tuners */
				if ((TunerError == TUNER_NO_ERR)
				    && (Tuner2Error == TUNER_NO_ERR))
					/*if no error on the tuner1 and 2 */
					error = FE_LLA_NO_ERROR;
				else if ((TunerError == TUNER_INVALID_HANDLE)
					 || (Tuner2Error ==
					     TUNER_INVALID_HANDLE))
					/*if tuner1 or 2 type error */
					error = FE_LLA_INVALID_HANDLE;
				else if ((TunerError == TUNER_TYPE_ERR)
					 || (Tuner2Error == TUNER_TYPE_ERR))
					/*if tuner1 or 2 NULL Handle
					 * error = FE_LLA_INVALIDE_HANDLE */
					error = FE_LLA_BAD_PARAMETER;
				else if ((TunerError != TUNER_NO_ERR)
					 || (Tuner2Error != TUNER_NO_ERR))
					error = FE_LLA_I2C_ERROR;
			} else {
				if (DemodError == CHIPERR_INVALID_HANDLE)
					error = FE_LLA_INVALID_HANDLE;
				else
					error = FE_LLA_I2C_ERROR;
			}
#endif
			pParams->MasterClock_Hz =
			    FE_367qam_GetMclkFreq(pParams->hDemod,
						  pParams->Crystal_Hz);
			pParams->AdcClock_Hz =
			    FE_367qam_GetADCFreq(pParams->hDemod,
						 pParams->Crystal_Hz);

		} else {
#ifdef HOST_PC
#ifdef NO_GUI
			FE_TunerTerm(pParams->hTuner);
			if (pParams->hTuner2)
				FE_TunerTerm(pParams->hTuner2);
			ChipClose(pParams->hDemod);
#endif
			free(pParams);
#endif
			pParams = NULL;
			error = FE_LLA_INVALID_HANDLE;
		}
	}

	return error;
}

/*****************************************************
--FUNCTION	::	FE_367qam_Algo
--ACTION	::	Driver functio of the STV0367QAM chip
--PARAMS IN	::	*pIntParams	==>	Demod handle
--						Tuner handle
						Search frequency
						Symbolrate
						QAM Size
						DerotOffset
						SweepRate
						Search Range
						Master clock
						ADC clock
						Structure for result storage
--PARAMS OUT::	NONE
--RETURN	::	Handle to STV0367QAM
--***************************************************/
FE_367qam_SIGNALTYPE_t FE_367qam_Algo(FE_367qam_InternalParams_t *pIntParams)
{
	/* Signal search status initialization */
	FE_367qam_SIGNALTYPE_t signalType = FE_367qam_NOAGC;
	U32 QAMFEC_Lock, QAM_Lock, u32_tmp, TunerLock;
	U32 LockTime, TRLTimeOut, AGCTimeOut, CRLSymbols, CRLTimeOut,
	    EQLTimeOut, DemodTimeOut, FECTimeOut;
	U8 TrackAGCAccum;

#ifdef HOST_PC
#if defined(DBG_SEARCHALGO) && !defined(NO_GUI)
	char text[1000];
	double searchtime = Timer();
	char state[][19] = {
		"FE_367qam_NOAGC", "FE_367qam_NOSIGNAL", "FE_367qam_NOTIMING",
		"FE_367qam_TIMINGOK", "FE_367qam_NOCARRIER",
		"FE_367qam_CARRIEROK",
		"FE_367qam_NOBLIND", "FE_367qam_BLINDOK", "FE_367qam_NODEMOD",
		"FE_367qam_DEMODOK", "FE_367qam_DATAOK"
	};
	ReportInsertMessage("SEARCH >> FE_367qam_Algo::Timeouts calculation");
#endif
#endif
	/* Timeouts calculation */
	/* A max lock time of 25 ms is allowed for delayed AGC */
	AGCTimeOut = 25;
	/* 100000 symbols needed by the TRL as a maximum value */
	TRLTimeOut = 100000000 / pIntParams->SymbolRate_Bds;
	/* CRLSymbols is the needed number of symbols to achieve a lock within
	 [-4%, +4%] of the symbol rate. CRL timeout is calculated for a lock
	 within [-SearchRange_Hz, +SearchRange_Hz].  EQL timeout can be changed
	 depending on the micro - reflections we want to handle.  A
	 characterization must be performed with these echoes to get new
	 timeout values.
	 */
	switch (pIntParams->Modulation) {
	case FE_CAB_MOD_QAM16:
		CRLSymbols = 150000;
		EQLTimeOut = 100;
		break;
	case FE_CAB_MOD_QAM32:
		CRLSymbols = 250000;
		EQLTimeOut = 100;
		break;
	case FE_CAB_MOD_QAM64:
		CRLSymbols = 200000;
		EQLTimeOut = 100;
		break;
	case FE_CAB_MOD_QAM128:
		CRLSymbols = 250000;
		EQLTimeOut = 100;
		break;
	case FE_CAB_MOD_QAM256:
		CRLSymbols = 250000;
		EQLTimeOut = 100;
		break;
	default:
		CRLSymbols = 200000;
		EQLTimeOut = 100;
		break;
	}
	if (pIntParams->SearchRange_Hz < 0) {
		CRLTimeOut =
		    (25 * CRLSymbols * (-pIntParams->SearchRange_Hz / 1000)) /
		    (pIntParams->SymbolRate_Bds / 1000);
	} else {
		CRLTimeOut =
		    (25 * CRLSymbols * (pIntParams->SearchRange_Hz / 1000)) /
		    (pIntParams->SymbolRate_Bds / 1000);
	}
	CRLTimeOut = (1000 * CRLTimeOut) / pIntParams->SymbolRate_Bds;
	/* Timeouts below 50ms are coerced */
	if (CRLTimeOut < 50)
		CRLTimeOut = 50;
	/* A maximum of 100 TS packets is needed to get FEC lock even in case
	  the spectrum inversion needs to be changed.  This is equal to 20 ms
	  in case of the lowest symbol rate of 0.87Msps
	 */
	FECTimeOut = 20;
	DemodTimeOut = AGCTimeOut + TRLTimeOut + CRLTimeOut + EQLTimeOut;
	/* Reset the TRL to ensure nothing starts until the
	   AGC is stable which ensures a better lock time
	 */
#ifdef HOST_PC
#if defined(DBG_SEARCHALGO) && !defined(NO_GUI)
	ReportInsertMessage("SEARCH >> FE_367qam_Algo::Registers setting");
#endif
#endif
	ChipSetOneRegister(pIntParams->hDemod, R367qam_CTRL_1, 0x04);
	/* Set AGC accumulation time to minimum and lock threshold to maximum
	 * in order to speed up the AGC lock */
	TrackAGCAccum =
	    ChipGetField(pIntParams->hDemod, F367qam_AGC_ACCUMRSTSEL);
	ChipSetField(pIntParams->hDemod, F367qam_AGC_ACCUMRSTSEL, 0x0);
	/* Modulus Mapper is disabled */
	ChipSetField(pIntParams->hDemod, F367qam_MODULUSMAP_EN, 0);
	/* Disable the sweep function */
	ChipSetField(pIntParams->hDemod, F367qam_SWEEP_EN, 0);
	/* The sweep function is never used, Sweep rate must be set to 0 */
	/* Set the derotator frequency in Hz */
	FE_367qam_SetDerotFreq(pIntParams->hDemod, pIntParams->AdcClock_Hz,
			       (1000 *
				(S32) FE_TunerGetIF_Freq(pIntParams->hTuner) +
				pIntParams->DerotOffset_Hz));
	/* Disable the Allpass Filter when the symbol rate is out of range */
	if ((pIntParams->SymbolRate_Bds > 10800000)
	    || (pIntParams->SymbolRate_Bds < 1800000)) {
		ChipSetField(pIntParams->hDemod, F367qam_ADJ_EN, 0);
		ChipSetField(pIntParams->hDemod, F367qam_ALLPASSFILT_EN, 0);
	}
#ifdef HOST_PC
#if defined(DBG_SEARCHALGO) && !defined(NO_GUI)
	searchtime = Timer() - searchtime;
	snprintf(text, sizeof(text),
		"SEARCH >> FE_367qam_Algo::Registers setting time: %.3f s",
		searchtime);
	ReportInsertMessage(text);
	searchtime = Timer();
#endif
#endif
	/* Check if the tuner is locked */
	TunerLock = FE_TunerGetStatus(pIntParams->hTuner);
	if (TunerLock == 0) {
#ifdef HOST_PC
#if defined(DBG_SEARCHALGO) && !defined(NO_GUI)
		snprintf(text, sizeof(text),
				"SEARCH >> FE_367qam_Algo::Tuner did not lock");
		ReportInsertMessage(text);
#endif
#endif
		return FE_367qam_NOTUNER;
	}
#ifdef HOST_PC
#if defined(DBG_SEARCHALGO) && !defined(NO_GUI)
	ReportInsertMessage("SEARCH >> FE_367qam_Algo::Tuner locked");
#endif
#endif
	/* Relase the TRL to start demodulator acquisition */
	/* Wait for QAM lock */
	LockTime = 0;
	ChipSetOneRegister(pIntParams->hDemod, R367qam_CTRL_1, 0x00);
	do {
		QAM_Lock = ChipGetField(pIntParams->hDemod, F367qam_FSM_STATUS);
		if ((LockTime >= (DemodTimeOut - EQLTimeOut))
		    && (QAM_Lock == 0x04))
			/* We don't wait longer, the frequency/phase offset
			 * must be too big */
			LockTime = DemodTimeOut;
		else if ((LockTime >= (AGCTimeOut + TRLTimeOut))
			 && (QAM_Lock == 0x02))
			/* We don't wait longer, either there is no signal or
			 * it is not the right symbol rate or it is an analog
			 * carrier */
		{
			LockTime = DemodTimeOut;
			ChipGetRegisters(pIntParams->hDemod,
					 R367qam_AGC_PWR_RD_L, 3);
			u32_tmp =
			    ChipGetFieldImage(pIntParams->hDemod,
					      F367qam_AGC_PWR_WORD_LO)
			    +
			    (ChipGetFieldImage
			     (pIntParams->hDemod, F367qam_AGC_PWR_WORD_ME) << 8)
			    +
			    (ChipGetFieldImage
			     (pIntParams->hDemod,
			      F367qam_AGC_PWR_WORD_HI) << 16);
			if (u32_tmp >= 131072)
				u32_tmp = 262144 - u32_tmp;
			u32_tmp =
			    u32_tmp /
			    (PowOf2
			     (11 -
			      ChipGetField(pIntParams->hDemod,
					   F367qam_AGC_IF_BWSEL)));

			if (u32_tmp <
			    ChipGetField(pIntParams->hDemod,
					 F367qam_AGC_PWRREF_LO) +
			    256 * ChipGetField(pIntParams->hDemod,
					       F367qam_AGC_PWRREF_HI) - 10)
				QAM_Lock = 0x0f;
		} else {
			/* wait 10 ms */
			ChipWaitOrAbort(pIntParams->hDemod, 10);
			LockTime += 10;
		}
	} while (((QAM_Lock != 0x0c) && (QAM_Lock != 0x0b))
		 && (LockTime < DemodTimeOut));
	if ((QAM_Lock == 0x0c) || (QAM_Lock == 0x0b)) {
		/* Wait for FEC lock */
		LockTime = 0;
		do {
			ChipWaitOrAbort(pIntParams->hDemod, 5);	/* wait 5 ms */
			LockTime += 5;
			QAMFEC_Lock =
			    ChipGetField(pIntParams->hDemod,
					 F367qam_QAMFEC_LOCK);
		} while (!QAMFEC_Lock && (LockTime < FECTimeOut));
	} else
		QAMFEC_Lock = 0;
#ifdef HOST_PC
#if defined(DBG_SEARCHALGO) && !defined(NO_GUI)
	snprintf(text, sizeof(text), "SEARCH >> FE_367qam_Algo::QAMFEC is %s",
		QAMFEC_Lock ? "locked" : "not locked");
	ReportInsertMessage(text);
#endif
#endif
	if (QAMFEC_Lock) {
		signalType = FE_367qam_DATAOK;
		pIntParams->DemodResult.Modulation = pIntParams->Modulation;
		if (FE_TunerGetIF_Freq(pIntParams->hTuner) != 0) {
			if (FE_TunerGetIF_Freq(pIntParams->hTuner) >
			    pIntParams->AdcClock_Hz / 1000) {
				pIntParams->DemodResult.Frequency_kHz =
				    FE_TunerGetFrequency(pIntParams->hTuner) -
				    FE_367qam_GetDerotFreq(pIntParams->hDemod,
					pIntParams->AdcClock_Hz) -
					pIntParams->AdcClock_Hz / 1000 +
					FE_TunerGetIF_Freq(pIntParams->hTuner);
				pIntParams->DemodResult.SpectInv =
				    ChipGetField(pIntParams->hDemod,
						 F367qam_QUAD_INV);
			} else {
				switch (FE_TunerGetModelName
					(pIntParams->hTuner)) {
					/* these tuners invert the spectrum */
				case TUNER_TDA18212:
				case TUNER_TDA18219:
				case TUNER_TDA18250:
				case TUNER_TDA18250A:
					pIntParams->DemodResult.Frequency_kHz =
					    FE_TunerGetFrequency
					    (pIntParams->hTuner) -
					    FE_367qam_GetDerotFreq
					    (pIntParams->hDemod,
					     pIntParams->AdcClock_Hz)
					    +
					    FE_TunerGetIF_Freq
					    (pIntParams->hTuner);
					pIntParams->DemodResult.SpectInv =
					    !(ChipGetField
					      (pIntParams->hDemod,
					       F367qam_QUAD_INV));
					break;
				default:
					pIntParams->DemodResult.Frequency_kHz =
					    FE_TunerGetFrequency
					    (pIntParams->hTuner) +
					    FE_367qam_GetDerotFreq
					    (pIntParams->hDemod,
					     pIntParams->AdcClock_Hz)
					    -
					    FE_TunerGetIF_Freq
					    (pIntParams->hTuner);
					pIntParams->DemodResult.SpectInv =
					    ChipGetField(pIntParams->hDemod,
							 F367qam_QUAD_INV);
					break;
				}
			}
		} else {
			pIntParams->DemodResult.Frequency_kHz =
			    FE_TunerGetFrequency(pIntParams->hTuner) +
			    FE_367qam_GetDerotFreq(pIntParams->hDemod,
						   pIntParams->AdcClock_Hz) -
			    pIntParams->AdcClock_Hz / 4000;
		}
		pIntParams->DemodResult.SymbolRate_Bds =
		    FE_367qam_GetSymbolRate(pIntParams->hDemod,
					    pIntParams->MasterClock_Hz);
		pIntParams->DemodResult.Locked = 1;
#ifdef HOST_PC
#if defined(DBG_SEARCHALGO) && !defined(NO_GUI)
		snprintf(text, sizeof(text),
			"SEARCH >> FE_367qam_Algo::Channel frequency = %.3fMHz",
			(double)(pIntParams->DemodResult.Frequency_kHz) /
			1000.0);
		ReportInsertMessage(text);
		snprintf(text, sizeof(text),
			"SEARCH >> FE_367qam_Algo::Symbol rate = %.3f kBds",
			(double)(pIntParams->DemodResult.SymbolRate_Bds) /
			1000.0);
		ReportInsertMessage(text);
#endif
#endif

/*		ChipSetField(pIntParams->hDemod, F367qam_AGC_ACCUMRSTSEL, 7);*/
	} else {
		switch (QAM_Lock) {
		case 1:
			signalType = FE_367qam_NOAGC;
			break;
		case 2:
			signalType = FE_367qam_NOTIMING;
			break;
		case 3:
			signalType = FE_367qam_TIMINGOK;
			break;
		case 4:
			signalType = FE_367qam_NOCARRIER;
			break;
		case 5:
			signalType = FE_367qam_CARRIEROK;
			break;
		case 7:
			signalType = FE_367qam_NOBLIND;
			break;
		case 8:
			signalType = FE_367qam_BLINDOK;
			break;
		case 10:
			signalType = FE_367qam_NODEMOD;
			break;
		case 11:
			signalType = FE_367qam_DEMODOK;
			break;
		case 12:
			signalType = FE_367qam_DEMODOK;
			break;
		case 13:
			signalType = FE_367qam_NODEMOD;
			break;
		case 14:
			signalType = FE_367qam_NOBLIND;
			break;
		case 15:
			signalType = FE_367qam_NOSIGNAL;
			break;
		default:
			break;
		}
#ifdef HOST_PC
#if defined(DBG_SEARCHALGO) && !defined(NO_GUI)
		snprintf(text, sizeof(text),
			"SEARCH >> FE_367qam_Algo::QAMFEC state is %s",
			state[signalType - 1]);
		ReportInsertMessage(text);
#endif
#endif
	}

	/* Set the AGC control values to tracking values */
	ChipSetField(pIntParams->hDemod, F367qam_AGC_ACCUMRSTSEL,
		     TrackAGCAccum);
#ifdef HOST_PC
#if defined(DBG_SEARCHALGO) && !defined(NO_GUI)
	ReportInsertMessage("SEARCH >> FE_367qam_Algo::End");
#endif
#endif
	return signalType;
}

/*****************************************************
--FUNCTION	::	FE_367qam_Search
--ACTION	::	Search for a valid channel
--PARAMS IN	::	Handle	==>	Front End Handle
				pSearch ==> Search parameters
				pResult ==> Result of the search
--PARAMS OUT::	NONE
--RETURN	::	Error(if any)
--***************************************************/
FE_LLA_Error_t FE_367qam_Search(FE_367qam_Handle_t Handle,
				FE_CAB_SearchParams_t *pSearch,
				FE_CAB_SearchResult_t *pResult)
{
	FE_LLA_Error_t error = FE_LLA_NO_ERROR;
	FE_367qam_InternalParams_t *pIntParams;
	U32 ZigzagScan = 0;

#ifdef HOST_PC
#if defined(DBG_SEARCHALGO) && !defined(NO_GUI)
	char text[1000];
	double searchtime;
#endif
#endif

	if ((void *)Handle == NULL) {
#ifdef HOST_PC
#if defined(DBG_SEARCHALGO) && !defined(NO_GUI)
		ReportInsertMessage("/********************************/");
		ReportInsertMessage
		    ("  Non - valid front - end handle. Search not performed");
		ReportInsertMessage("/*****************************/");
#endif
#endif
		error = FE_LLA_INVALID_HANDLE;
		return error;
	}
	pIntParams = (FE_367qam_InternalParams_t *)Handle;

	if ((pIntParams->hDemod->Error) || (pIntParams->hTuner->Error)) {
		error = FE_LLA_I2C_ERROR;
		return error;
	}
	if ((pSearch == NULL) || (pResult == NULL)) {
#ifdef HOST_PC
#if defined(DBG_SEARCHALGO) && !defined(NO_GUI)
		ReportInsertMessage
		    ("/*****************************************/");
		ReportInsertMessage
		    ("  Bad search parameters. Search not performed");
		ReportInsertMessage
		    ("/********************************/");
#endif
#endif
		error = FE_LLA_BAD_PARAMETER;
		return error;
	}
#ifdef HOST_PC
#if defined(DBG_SEARCHALGO) && !defined(NO_GUI)
	searchtime = Timer();
	ReportInsertMessage
	    ("SEARCH >> FE_367qam_Search::Begin");
	snprintf(text, sizeof(text),
	     "SEARCH >> FE_367qam_Search::Searched frequency: %.3f MHz",
	     (double)(pSearch->Frequency_kHz) / 1000.0);
	ReportInsertMessage(text);
	snprintf(text, sizeof(text),
	       "SEARCH >> FE_367qam_Search::Searched modulation: QAM%d",
	       (int)((pSearch->Modulation < 1) ? 4 : 8 * pow(2,
					pSearch->Modulation)));
	ReportInsertMessage(text);
	snprintf(text, sizeof(text),
	     "SEARCH >> FE_367qam_Search::Searched SymbolRate: %d ksps",
	     pSearch->SymbolRate_Bds / 1000);
	ReportInsertMessage(text);
#endif
#endif
	/* Search Parameters copied into the internal parameters
	 * structure */
	pIntParams->Frequency_kHz = pSearch->Frequency_kHz;
	pIntParams->SymbolRate_Bds = pSearch->SymbolRate_Bds;
	pIntParams->SearchRange_Hz = pSearch->SearchRange_Hz;
	pIntParams->DerotOffset_Hz = 0;
	pIntParams->Modulation = pSearch->Modulation;
	/* PJ/TA 06/2010 */
	pIntParams->FirstTimeBER = 1;
	/* Tuner Frequency Setting */
	/* Bandwidth is set first for NXP Si Tuners */
#ifdef HOST_PC
#if defined(DBG_SEARCHALGO) && !defined(NO_GUI)
	tunersearchtime = Timer();
	ReportInsertMessage("SEARCH >> FE_367qam_Search::Tuner setting");
#endif
#endif
	switch (FE_TunerGetModelName(pIntParams->hTuner)) {
	case TUNER_TDA18250:
	case TUNER_TDA18212:
	case TUNER_FJ222:
	case TUNER_MXL603:
	case TUNER_TDA18250A:
		FE_TunerSetBandWidth(pIntParams->hTuner, 8);
		break;
	default:
		break;
	}
	FE_TunerSetFrequency(pIntParams->hTuner, pIntParams->Frequency_kHz);
#ifdef HOST_PC
#if defined(DBG_SEARCHALGO) && !defined(NO_GUI)
	tunersearchtime = Timer() - tunersearchtime;
	snprintf(text, sizeof(text),
		       "SEARCH >> FE_367qam_Search::Tuner setting time: %.3f s",
			tunersearchtime);
	ReportInsertMessage(text);
	ReportInsertMessage("SEARCH >> FE_367qam_Algo::Begin");
	snprintf(text, sizeof(text),
			"SEARCH >> FE_367qam_Algo::Derotator offset: %.3f kHz",
			(double)(pIntParams->DerotOffset_Hz) / 1000.0);
	ReportInsertMessage(text);
	snprintf(text, sizeof(text),
			"SEARCH >> FE_367qam_Algo::Search range: +/-%.3f kHz",
			(double)(ABS(pIntParams->SearchRange_Hz) / 1000.0));
	ReportInsertMessage(text);
#endif
#endif
	/* Sets QAM size and all related parameters */
	FE_367qam_SetQamSize(pIntParams->hDemod, pIntParams->hTuner,
			pIntParams->Frequency_kHz, pIntParams->SymbolRate_Bds,
			pIntParams->Modulation);
	/* Sets symbol and all related parameters */
	FE_367qam_SetSymbolRate(pIntParams->hDemod, pIntParams->AdcClock_Hz,
			pIntParams->MasterClock_Hz, pIntParams->SymbolRate_Bds,
			pIntParams->Modulation);
	/* Zigzag Algorithm test */
	if (25 * pIntParams->SearchRange_Hz > pIntParams->SymbolRate_Bds) {
		pIntParams->SearchRange_Hz = -(S32)(pIntParams->
						SymbolRate_Bds) / 25;
		ZigzagScan = 1;
	}
/* Search algorithm launch, [-1.1*RangeOffset, +1.1*RangeOffset] scan */
	pIntParams->State = FE_367qam_Algo(pIntParams);
#ifdef HOST_PC
#if defined(DBG_SEARCHALGO) && !defined(NO_GUI)
	ReportInsertMessage("SEARCH >> FE_367qam_Algo::End");
#endif
#endif
	if (ZigzagScan && (pIntParams->State != FE_367qam_DATAOK)) {
		do {
			pIntParams->SearchRange_Hz =
				-pIntParams->SearchRange_Hz;
			if (pIntParams->SearchRange_Hz > 0)
				pIntParams->DerotOffset_Hz =
				    -pIntParams->DerotOffset_Hz +
				    pIntParams->SearchRange_Hz;
			else
				pIntParams->DerotOffset_Hz =
					-pIntParams->DerotOffset_Hz;

#ifdef HOST_PC
#if defined(DBG_SEARCHALGO) && !defined(NO_GUI)
			ReportInsertMessage
				("SEARCH >> FE_367qam_Algo::Begin");
			snprintf(text, sizeof(text),
			 "SEARCH >> FE_367qam_Algo::Derotator offset: %.3f kHz",
			 (double)(pIntParams->DerotOffset_Hz) / 1000.0);
			ReportInsertMessage(text);
			snprintf(text, sizeof(text),
			  "SEARCH >> FE_367qam_Algo::Search range: +/-%.3f kHz",
			  (double)(ABS(pIntParams->SearchRange_Hz) / 1000.0));
			ReportInsertMessage(text);
#endif
#endif
			/* Search algorithm launch,
			 * [-1.1*RangeOffset,
			 * +1.1*RangeOffset] scan */
			pIntParams->State = FE_367qam_Algo(pIntParams);
#ifdef HOST_PC
#if defined(DBG_SEARCHALGO) && !defined(NO_GUI)
			ReportInsertMessage("SEARCH >> FE_367qam_Algo::End");
#endif
#endif
		} while (((pIntParams->DerotOffset_Hz +
				pIntParams->SearchRange_Hz) >=
					-(S32)pSearch->SearchRange_Hz)
			&& (pIntParams->State != FE_367qam_DATAOK));
	}
#ifdef HOST_PC
#if defined(DBG_SEARCHALGO) && !defined(NO_GUI)
	searchtime = Timer() - searchtime;
	snprintf(text, sizeof(text),
			"SEARCH >> FE_367qam_Search::Search time: %.3f s",
			searchtime);
	ReportInsertMessage(text);
#endif
#endif
	/* check results */
	if ((pIntParams->State == FE_367qam_DATAOK) &&
		     (pIntParams->hDemod->Error == CHIPERR_NO_ERROR) &&
		     (pIntParams->hTuner->Error == CHIPERR_NO_ERROR)) {
		FE_367qam_ClearCounters(pIntParams->hDemod,
				&pIntParams->Monitor_results);
#ifdef HOST_PC
#if defined(DBG_SEARCHALGO) && !defined(NO_GUI)
		ReportInsertMessage("/****** SEARCH SUCCESSFUL *******/");
		ReportInsertMessage("/********************************/");
		ReportInsertMessage("  SEARCH END");
		ReportInsertMessage("/********************************/");
#endif
#endif
		/* update results */
		pResult->Locked = (pIntParams->State == FE_367qam_DATAOK) ?
								TRUE : FALSE;
		pResult->Frequency_kHz = pIntParams->
					 DemodResult.Frequency_kHz;
		pResult->SymbolRate_Bds = pIntParams->
					  DemodResult.SymbolRate_Bds;
		pResult->SpectInv = pIntParams->DemodResult.SpectInv;
		pResult->Modulation = pIntParams->DemodResult.Modulation;
	} else {
#ifdef HOST_PC
#if defined(DBG_SEARCHALGO) && !defined(NO_GUI)
		ReportInsertMessage("/****** SEARCH FAILED *******/");
		ReportInsertMessage("/****************************/");
		ReportInsertMessage("  SEARCH END");
		ReportInsertMessage("/****************************/");
#endif
#endif
		pResult->Locked = FALSE;
		error = FE_LLA_SEARCH_FAILED;
	}

	if ((pIntParams->hDemod->Error) || (pIntParams->hTuner->Error))
		error = FE_LLA_I2C_ERROR;
	return error;
}

BOOL FE_367qam_Status(FE_367qam_Handle_t Handle)
{
	FE_367qam_InternalParams_t *pParams = NULL;

	pParams = (FE_367qam_InternalParams_t *) Handle;

	return ChipGetField(pParams->hDemod, F367qam_QAMFEC_LOCK);
}

U32 FE_367qam_GetQAMFECLockStatus(FE_367qam_Handle_t Handle)
{

	FE_367qam_InternalParams_t *pParams = NULL;

	pParams = (FE_367qam_InternalParams_t *) Handle;

	return ChipGetField(pParams->hDemod, F367qam_QAMFEC_LOCK);
}

/*****************************************************
--FUNCTION	::	FE_STV0367qam_SetStandby
--ACTION	::	Set demod STANDBAY mode On/Off
--PARAMS IN	::	Handle	==>	Front End Handle

-PARAMS OUT::	NONE.
--RETURN	::	Error(if any)
--***************************************************/
FE_LLA_Error_t FE_367qam_SetStandby(FE_367qam_Handle_t Handle, U8 StandbyOn)
{
	FE_LLA_Error_t error = FE_LLA_NO_ERROR;
	FE_367qam_InternalParams_t *pParams =
	    (FE_367qam_InternalParams_t *) Handle;

	if (pParams != NULL) {
		if ((pParams->hDemod->Error) || (pParams->hTuner->Error)) {
			error = FE_LLA_I2C_ERROR;
		} else {
			if (StandbyOn) {
				FE_TunerSetStandbyMode(pParams->hTuner,
						       StandbyOn);
				ChipSetField(pParams->hDemod,
					     F367qam_BYPASS_PLLXN, 0x03);
				ChipSetField(pParams->hDemod,
					     F367qam_STDBY_PLLXN, 0x01);
				ChipSetField(pParams->hDemod, F367qam_STDBY, 1);
				ChipSetField(pParams->hDemod,
					     F367qam_STDBY_CORE, 1);
				ChipSetField(pParams->hDemod,
					     F367qam_EN_BUFFER_I, 0);
				ChipSetField(pParams->hDemod,
					     F367qam_EN_BUFFER_Q, 0);
				ChipSetField(pParams->hDemod, F367qam_POFFQ, 1);
				ChipSetField(pParams->hDemod, F367qam_POFFI, 1);
			} else {
				ChipSetField(pParams->hDemod,
					     F367qam_STDBY_PLLXN, 0x00);
				ChipSetField(pParams->hDemod,
					     F367qam_BYPASS_PLLXN, 0x00);
				ChipSetField(pParams->hDemod, F367qam_STDBY, 0);
				ChipSetField(pParams->hDemod,
					     F367qam_STDBY_CORE, 0);
				ChipSetField(pParams->hDemod,
					     F367qam_EN_BUFFER_I, 1);
				ChipSetField(pParams->hDemod,
					     F367qam_EN_BUFFER_Q, 1);
				ChipSetField(pParams->hDemod, F367qam_POFFQ, 0);
				ChipSetField(pParams->hDemod, F367qam_POFFI, 0);
				FE_TunerSetStandbyMode(pParams->hTuner,
						       StandbyOn);
			}
			if ((pParams->hDemod->Error)
			    || (pParams->hTuner->Error)) {
				error = FE_LLA_I2C_ERROR;
			}
		}
	} else
		error = FE_LLA_INVALID_HANDLE;

	return error;
}

/*****************************************************
--FUNCTION	::	FE_367qam_GetSignalInfo
--ACTION	::	Return informations on the locked channel
--PARAMS IN	::	Handle	==>	Front End Handle
--PARAMS OUT::	pInfo	==> Informations(BER, C/N, power ...)
--RETURN	::	Error(if any)
--***************************************************/
FE_LLA_Error_t FE_367qam_GetSignalInfo(FE_367qam_Handle_t Handle,
				       FE_CAB_SignalInfo_t *pInfo)
{
	FE_LLA_Error_t error = FE_LLA_NO_ERROR;
	FE_367qam_InternalParams_t *pParams = NULL;
	U32 WaitingTime = 0;

	pParams = (FE_367qam_InternalParams_t *) Handle;

	if (pParams == NULL)
		return FE_LLA_INVALID_HANDLE;

	if ((pParams->hDemod->Error) || (pParams->hTuner->Error))
		return FE_LLA_I2C_ERROR;
	pInfo->Locked =
	    ChipGetField(pParams->hDemod, F367qam_QAMFEC_LOCK);

	if (pInfo->Locked) {
		if (FE_TunerGetIF_Freq(pParams->hTuner) != 0) {
			if (FE_TunerGetIF_Freq(pParams->hTuner) >
					pParams->AdcClock_Hz / 1000) {
				pInfo->Frequency =
					FE_TunerGetFrequency(pParams->hTuner) -
					FE_367qam_GetDerotFreq(pParams->hDemod,
							pParams->AdcClock_Hz) -
					pParams->AdcClock_Hz / 1000 +
					FE_TunerGetIF_Freq(pParams->hTuner);
			} else {
				switch (FE_TunerGetModelName(pParams->hTuner)) {
				/* these tuners invert the
				 * spectrum */
				case TUNER_TDA18212:
				case TUNER_TDA18219:
				case TUNER_TDA18250:
				case TUNER_TDA18250A:
					pInfo->Frequency =
					  FE_TunerGetFrequency(pParams->hTuner)
					  - FE_367qam_GetDerotFreq(pParams->
						   hDemod, pParams->AdcClock_Hz)
					  + FE_TunerGetIF_Freq(pParams->hTuner);
					pInfo->SpectInversion =
					  !(ChipGetField(pParams->hDemod,
							     F367qam_QUAD_INV));
					break;
				default:
					pInfo->Frequency =
					  FE_TunerGetFrequency(pParams->hTuner)
					  + FE_367qam_GetDerotFreq(pParams->
						   hDemod, pParams->AdcClock_Hz)
					  - FE_TunerGetIF_Freq(pParams->hTuner);
					pInfo->SpectInversion =
					    ChipGetField(pParams->hDemod,
							    F367qam_QUAD_INV);
					break;
				}

			}
		} else {
			pInfo->Frequency = FE_TunerGetFrequency(pParams->hTuner)
				+ FE_367qam_GetDerotFreq(pParams->hDemod,
						pParams->AdcClock_Hz) -
				pParams->AdcClock_Hz / 4000;
		}

		pInfo->SymbolRate = FE_367qam_GetSymbolRate(pParams->hDemod,
						       pParams->MasterClock_Hz);
		pInfo->Modulation = ChipGetField(pParams->hDemod,
							F367qam_QAM_MODE);
		FE_367qam_GetRFLevel(pParams->hDemod,
				     pParams->hTuner,
				     &pParams->Monitor_results);
		pInfo->RFLevelx10dBm_s32 = pParams->
			Monitor_results.FE_367qam_RFLevelx10dBm_s32;
		pInfo->RFLevelx100Percent_u32 = pParams->Monitor_results.
			FE_367qam_RFLevelx100Percent_u32;
		FE_367qam_GetCarrierToNoiseRatio_u32(pParams->hDemod,
			&pParams->Monitor_results,
			ChipGetField(pParams->hDemod, F367qam_QAM_MODE));
		pInfo->SNRx10dB_u32 = pParams->
			Monitor_results.FE_367qam_SNRx10dB_u32;
		pInfo->SNRx100Percent_u32 = pParams->Monitor_results.
			FE_367qam_SNRx100Percent_u32;
		if (pParams->FirstTimeBER) {
			pParams->FirstTimeBER = 0;

			switch (pInfo->Modulation) {
			case FE_CAB_MOD_QAM16:
			case FE_CAB_MOD_QAM32:
				ChipSetField(pParams->hDemod,
						F367qam_BERT_NBYTE, 2);
				break;
			default:
				ChipSetField(pParams->hDemod,
						F367qam_BERT_NBYTE, 2);
				break;
			}
			FE_367qam_ClearCounters(pParams->hDemod,
					&pParams->Monitor_results);
			FE_367qam_GetWaitingTime(pParams->hDemod,
					pInfo->Modulation, pInfo->SymbolRate,
					&pParams->Monitor_results);
			WaitingTime = pParams->Monitor_results.
				FE_367qam_WaitingTime_ms;
			ChipWaitOrAbort(pParams->hDemod, WaitingTime);
		}
		FE_367qam_GetErrorCount(pParams->hDemod, pInfo->Modulation,
				pInfo->SymbolRate, &
				(pParams->Monitor_results));

		pInfo->BERxE7_u32 = pParams->
			Monitor_results.FE_367qam_BERxE7_u32;
		pInfo->PERxE7_u32 = pParams->
			Monitor_results.FE_367qam_PERxE7_u32;
#ifdef HOST_PC
		pInfo->BER_dbl = pParams->Monitor_results.FE_367qam_BER_dbl;
		pInfo->PER_dbl = pParams->Monitor_results.FE_367qam_PER_dbl;
		pInfo->RFLeveldBm_dbl = pParams->
			Monitor_results.FE_367qam_RFLeveldBm_dbl;
		FE_367qam_GetCarrierToNoiseRatio_dbl(pParams->hDemod,
				&(pParams->Monitor_results),
				ChipGetField(pParams->hDemod,
					F367qam_QAM_MODE));
		pInfo->SNRdB_dbl = pParams->
			Monitor_results.FE_367qam_SNRdB_dbl;
#endif
	}
	if ((pParams->hDemod->Error) || (pParams->hTuner->Error))
		error = FE_LLA_I2C_ERROR;

	return error;
}

/*****************************************************
--FUNCTION	::	FE_367qam_Term
--ACTION	::	Terminate STV0367QAM chip connection
--PARAMS IN	::	Handle	==>	Front End Handle
--PARAMS OUT::	NONE
--RETURN	::	Error(if any)
--***************************************************/
FE_LLA_Error_t FE_367qam_Term(FE_367qam_Handle_t Handle)
{
	FE_LLA_Error_t error = FE_LLA_NO_ERROR;
	FE_367qam_InternalParams_t *pParams = NULL;

	pParams = (FE_367qam_InternalParams_t *) Handle;

	if (pParams != NULL) {
#ifdef HOST_PC
#ifdef NO_GUI
		if (pParams->hTuner2)
			FE_TunerTerm(pParams->hTuner2);
		FE_TunerTerm(pParams->hTuner);
		ChipClose(pParams->hDemod);
#endif

		free(pParams);
#endif

	} else
		error = FE_LLA_INVALID_HANDLE;

	return error;
}

/*****************************************************
--FUNCTION	::	FE_367qam_SuccessRate
--ACTION	::	Search for a valid channel
--PARAMS IN	::	Handle	==>	Front End Handle
				pSearch ==> Search parameters
				RFOffset ==> Emulated Frequency offset
--PARAMS OUT::	NONE
--RETURN	::	Error(if any)
--***************************************************/
FE_LLA_Error_t FE_367qam_SuccessRate(FE_367qam_Handle_t Handle,
				     FE_CAB_SearchParams_t *pSearch,
				     S32 RFOffset_kHz)
{

	FE_LLA_Error_t error = FE_LLA_NO_ERROR;
	FE_367qam_InternalParams_t *pIntParams;
	U32 ZigzagScan = 0;
	if ((void *)Handle != NULL) {
		pIntParams = (FE_367qam_InternalParams_t *) Handle;

		if (pSearch != NULL) {
			/* Search Parameters copied into the internal
			 * parameters structure */
			pIntParams->Frequency_kHz = pSearch->Frequency_kHz;
			pIntParams->SymbolRate_Bds = pSearch->SymbolRate_Bds;
			pIntParams->SearchRange_Hz = pSearch->SearchRange_Hz;
			/* pIntParams->DerotOffset_Hz = 0; */
			pIntParams->DerotOffset_Hz = 1000 * RFOffset_kHz;
			pIntParams->Modulation = pSearch->Modulation;
			/* Tuner Frequency Setting */
			/* FE_Cab_TunerSetFrequency(pIntParams->hTuner,
			(U32)((S32)(pIntParams->Frequency_kHz)+RFOffset_kHz));*/
			/* Bandwidth is set first for NXP Si Tuners */
			switch (FE_TunerGetModelName(pIntParams->hTuner)) {
			case TUNER_TDA18250:
			case TUNER_TDA18212:
			case TUNER_FJ222:
			case TUNER_MXL603:
			case TUNER_TDA18250A:
				FE_TunerSetBandWidth(pIntParams->hTuner, 8);
				break;
			default:
				break;
			}
			FE_TunerSetFrequency(pIntParams->hTuner,
					     pIntParams->Frequency_kHz);
			/* Sets the QAM size and all the related parameters */
			FE_367qam_SetQamSize(pIntParams->hDemod,
					     pIntParams->hTuner,
					     (U32) ((S32)
						    pIntParams->Frequency_kHz +
						    RFOffset_kHz),
					     pIntParams->SymbolRate_Bds,
					     pIntParams->Modulation);
			/* Sets the symbol and all the related parameters */
			FE_367qam_SetSymbolRate(pIntParams->hDemod,
						pIntParams->AdcClock_Hz,
						pIntParams->MasterClock_Hz,
						pIntParams->SymbolRate_Bds,
						pIntParams->Modulation);

			/* Zigzag Algorithm test */
			if (25 * pIntParams->SearchRange_Hz >
			    pIntParams->SymbolRate_Bds) {
				pIntParams->SearchRange_Hz =
				    -(S32) (pIntParams->SymbolRate_Bds) / 25;
				ZigzagScan = 1;
			}

			/* Search algorithm launch, [-1.1*RangeOffset,
			 * +1.1*RangeOffset] scan */
			pIntParams->State = FE_367qam_Algo(pIntParams);
			if (ZigzagScan
			    && (pIntParams->State != FE_367qam_DATAOK)) {
				do {
					pIntParams->SearchRange_Hz =
					    -pIntParams->SearchRange_Hz;
					if (pIntParams->SearchRange_Hz > 0)
						pIntParams->DerotOffset_Hz =
						    -pIntParams->DerotOffset_Hz
						    +
						    pIntParams->SearchRange_Hz;
					else
						pIntParams->DerotOffset_Hz =
						    -pIntParams->DerotOffset_Hz;

					/* Search algorithm launch,
					 * [-1.1*RangeOffset, +1.1*RangeOffset]
					 * scan */
					pIntParams->State =
					    FE_367qam_Algo(pIntParams);
				} while (((pIntParams->DerotOffset_Hz +
					   pIntParams->SearchRange_Hz) >=
					  -(S32) pSearch->SearchRange_Hz)
					 && (pIntParams->State !=
					     FE_367qam_DATAOK));
			}
			/* check results */
			if ((pIntParams->State == FE_367qam_DATAOK) &&
			    (pIntParams->hDemod->Error == CHIPERR_NO_ERROR) &&
			    (pIntParams->hTuner->Error == CHIPERR_NO_ERROR))
				error = FE_LLA_NO_ERROR;
			else
				error = FE_LLA_SEARCH_FAILED;
		} else
			error = FE_LLA_BAD_PARAMETER;
	} else
		error = FE_LLA_INVALID_HANDLE;

	return error;
}

/*****************************************************
--FUNCTION :: FE_367qam_SetAbortFlag
--ACTION :: Set Abort flag On/Off
--PARAMS IN :: Handle ==> Front End Handle

-PARAMS OUT:: NONE.
--RETURN :: Error(if any)

--***************************************************/
FE_LLA_Error_t FE_367qam_SetAbortFlag(FE_367qam_Handle_t Handle, BOOL Abort)
{
	FE_LLA_Error_t error = FE_LLA_NO_ERROR;
	FE_367qam_InternalParams_t *pParams =
	    (FE_367qam_InternalParams_t *) Handle;

	if (pParams != NULL) {
		if ((pParams->hDemod->Error) || (pParams->hTuner->Error))
			error = FE_LLA_I2C_ERROR;
		else {
			ChipAbort(pParams->hTuner, Abort);
			ChipAbort(pParams->hDemod, Abort);
			/*Check the error at the end of the function */
			if ((pParams->hDemod->Error)
			    || (pParams->hTuner->Error))
				error = FE_LLA_I2C_ERROR;
		}
	} else
		error = FE_LLA_INVALID_HANDLE;
	return error;
}
